{"pages":[{"title":"UDOO Neo Docs","text":"","tags":"","url":"index.html"},{"title":"Introduction","text":"UDOO NEO UDOO NEO is an all-in-one open hardware low-cost computer equipped with a NXP\u2122 i.MX 6SoloX applications processor for Android and Linux. UDOO NEO embeds two cores on the same processor: a powerful 1GHz ARM\u00ae Cortex-A9, and an ARM Cortex-M4 I\/O real-time co-processor that can run up to 200Mhz. While the Cortex-A9 can run both Android Lollipop and UDOObuntu 2 - a dedicated Ubuntu-based Linux distro - the Cortex-M4 allows easy access to a Arduino\u2122 environment. The snap-in connector ensures a plug-and-play interaction with most sensors and actuators. Thanks to its embedded 9-axis motion sensors and a Wi-Fi + Bluetooth 4.0 module, the board is ideal to create robots, drones and rovers as well as any Mobile IoT project you can imagine. Heads up! In order to prevent damages to your board, remember to: Never provide more than 3.3V in input to the GPIOs Never keep the board in touch with metal objects or surfaces while it is powered up Lineup UDOO NEO retail line up consists of three models. Technical specifications NXP\u00ae i.MX 6SoloX applications processor with an embedded ARM Cortex-A9 core and a Cortex-M4 Core 512MB (Basic) or 1GB (only Extended and Full) Integrated 2d\/3d graphics controller Micro HDMI interface LVDS interface + touch (I2C signals) Analog camera connection supporting NTSC and PAL 8-bit parallel camera interface* HDMI audio transmitter S\/PIDF &amp; I2S* 1x USB 2.0 Type A ports 1x USB OTG (micro-AB connector) Fast ethernet RJ45 \u2013 10\/100Mbps (only Basic and Full) Wi-Fi 802.11 b\/g\/n,Direct Mode SmartConfig and Bluetooth 4.0 Low Energy (only Extended and Full) 3x UART ports* 2x CAN Bus interfaces* 8x PWM signals* 3x I2C interface* 1x SPI interface* 6x multiplexable signals* 5 V DC Micro USB 6-15 V DC Power Jack RTC Battery Connector Green Power Status LED User Configurable LEDs (Red and Orange) 3-Axis Accelerometer (only Extended and Full) 3-Axis Magnetometer (only Extended and Full) 3-Axis Digital Gyroscope (only Extended and Full) 1x Sensor Snap-In I2C connector 89mm x59mm (3.50\u2033 x 2.32\u2033) Arduino-Compatible through the standard Arduino Pins layout and compatible with Arduino shields. 32 extended GPIOs (A9 dedicated) 22 Arduino GPIOs (M4 dedicated) 6 available Pins Android Lollipop &amp; Linux UDOObuntu2 (14.04 LTS) *Available on Pin Header Community Official web site www.udoo.org Official forum www.udoo.org\/forum Forums The official UDOO forums can be found at www.udoo.org\/forum The forum search facility has been tweaked to allow more general searching. Please do a search before making a post as the issue may already have been raised and answered. IRC channel There is an (unofficial) UDOO discussion channel on IRC. Using the IRC client of your choice, use server information: irc.freenode.net. Room name is #udoo. Social networks Facebook fan page Twitter Google+ YouTube","tags":"","url":"Introduction\/Introduction.html"},{"title":"Very First Start","text":"Overview This easy step by step guide will lead you through the procedure to boot your UDOO for the very first time. What do you need? To use UDOO NEO as a computer you need: UDOO NEO; Micro SD card (at least 8GB), eventually preloaded with the Operating System; 12V 2A Power supply or USB Wall Charger 5V with Micro USB Data Cable; HDMI monitor or TV; Mouse; Keyboard; USB HUB or Host OTG Adapter Cable to add a second USB port (optional). To use UDOO Neo as a headless IoT device you need: UDOO NEO; Micro SD card (at least 8GB), eventually preloaded with the Operating System; 12V 2A Power supply or USB Wall Charger 5V with Micro USB Data Cable. 1. Download UDOO Neo\u2019s official Operating system: The main \u201cHard Drive\u201d of UDOO NEO is the Micro SD card. In order to get started you just need to download the official UDOObuntu Operating System and write it to your Micro SD card. Download any official Micro SD image from the image section of the website. 2. Burn UDOO Neo OS Follow the guide to create a bootable Micro SD card for UDOO NEO. 3. Insert the Micro SD card and power up! As a Headless Device Power up the board via a USB to Micro USB cable connected to a computer, through a power adapter or through a 5V USB Wall Charger. As a Computer Insert into your UDOO Neo the Micro SD card you just prepared; Plug Keyboard and Mouse; Connect your monitor via Micro HDMI Cable; Power up the board via a USB to Micro USB cable connected to a computer, through a power adapter or through a 5V USB Wall Charger; Connect the LAN cable (optional). 4. Ready! UDOO Neo will start, and you\u2019ve plenty of options to use it: Use UDOO Neo as a lightweight Desktop PC and developing platform Use UDOO Neo as a headless IoT device Use UDOO Neo as an Arduino","tags":"","url":"Getting_Started\/Very_First_Start.html"},{"title":"Create a bootable MicroSD card for UDOO Neo","text":"Overview The following paragraphs will guide you through the creation of a bootable Micro SD card for UDOO Neo, starting from a precompiled image file containing the UDOObuntu 2 or Android Lollipop Operating system, which runs on the i.MX6 processor. The procedure is quite easy: simply unzip the image and write it on the Micro SD card using the dd tool for UNIX\/MAC users or Win32DiskImager for Windows users. It is not possible to create a bootable Micro SD card with drag and drop. SD Card Requirements Please consider that the size of a Micro SD card must be at least 4\/8GB (depending on the operating system); Micro SD memory cards with a higher capacity (tested up to 64GB) may be used, and the Linux root partition will be expanded to the full SD card size during the first boot. Android images are not expanded and stuck at 8GB even if you use a bigger SD card; however you can expand your partitions manually using tools like gparted. OS Minimum SD size Maximum SD size Automatic expansion UDOObuntu Linux 4GB 64GB Yes Android 8GB 64GB No Step by Step Guide Download any official Micro SD image from the image section of the website. Extract the .img file from the .zip file you downloaded into any folder (this path will be referred to as &lt;img_file_path&gt; in the guide). Follow the instructions below for the OS you use: Windows Mac OS X Linux Extract the downloaded zip file, so you'll have a .img image file. Do not use the preinstalled archive extractor, use 7-zip or similar to decompress the zip file. Download the Win32DiskImager software and unzip it. If your PC has a slot for SD cards (you may need a Micro SD to SD adapter), simply insert the card. If not, insert the card into any SD card reader and then connect it to the PC. Run the file named Win32DiskImager.exe right-clicking it and selecting \u201cRun as administrator\u201d. If the Micro SD card (Device) used is not detected automatically, click on the drop down box on the right and select the identifier of the Micro SD card that has been plugged in (e.g. [H:]). If your Micro SD card is not listed, try to format it using the FAT32 file system. Heads up! Please be careful to select the correct drive identifier; if you use the wrong identifier you may lose all data in your PC! In the Image File box, choose the downloaded .img file and click \u201cWrite\u201d. Click yes in case a warning message pops up. The Micro SD card is now ready to be used. Simply insert it in the board\u2019s Micro SD Card slot and boot the system. If you have problems, have a look to the video tutorial Creating a bootable MicroSD card using Windows from image. From the Terminal app run df -h If your Mac has a slot for SD cards (you may need a Micro SD to SD adapter), simply insert the card. If not, insert the card into any SD card reader and then connect it to the Mac. Run again df -h The device that wasn't listed before is the Micro SD card just inserted. The name shown will be the one of the filesystem\u2019s partition, for example, \/dev\/disk3s1. Now consider the raw device name for using the entire disk, by omitting the final s1 and replacing disk with rdisk (considering the previous example, use rdisk3, not disk3 nor rdisk3s1). Heads up! Please be careful to select the correct device identifier; if you use the wrong identifier you may lose all data in your Mac! Unmount all the partitions in the SD card (use the correct name found previously, followed by letters and numbers that identify the partitions). using diskutil: sudo diskutil unmount \/dev\/disk3s1 Now write the image on the Micro SD card using the command: sudo dd bs=1m if=&lt;img_file_path&gt; of=\/dev\/&lt;sd_name&gt; Please make sure that you replaced the argument of input file (if=&lt;img_file_path&gt;) with the path to the .img file, and that the device name specified in output file\u2019s argument (of=\/dev\/&lt;sd_name&gt;) is correct. Please also make sure that the device name is the one of the whole Micro SD card as described above, not just a partition (for example, rdisk3, not disk3s1). For example: sudo dd bs=1m if=\/Users\/YourName\/Download\/udoo-neo-udoobuntu.img of=\/dev\/rdisk3 Once dd has been completed, run: sudo sync sudo diskutil eject \/dev\/rdisk3 The Micro SD card is now ready to be used. Simply insert it in the board\u2019s Micro SD Card slot and boot the system. If you have problems, have a look to the video tutorial Creating a bootable MicroSD card with Mac OSX from image. From the terminal run df -h If your PC has a slot for SD cards (you may need a Micro SD to SD adapter), simply insert the card. If not, insert the card into any SD card reader and then connect it to the PC. Run again df -h The device that wasn't listed before is the Micro SD card just inserted. The left column will show the device name assigned to the Micro SD card. It will have a name similar to \/dev\/mmcblk0p1 or \/dev\/sdd1. The last part of the name (p1 or 1, respectively) is the partition number, but it is necessary to write on the whole Micro SD card, not only on one partition. Therefore, it is necessary to remove that part from the name (for example \/dev\/mmcblk0 or \/dev\/sdd) in order to work with the whole Micro SD card. Heads up! Please be careful to select the correct device identifier; if you use the wrong identifier you may lose all data in your PC! Unmount all the partitions in the SD card (use the correct name found previously, followed by letters and numbers that identify the partitions). using umount: sudo umount \/dev\/sdd1 Now write the image on the Micro SD card using the command: sudo dd bs=1M if=&lt;img_file_path&gt; of=\/dev\/&lt;sd_name&gt; Please make sure that you replaced the argument of input file (if=&lt;img_file_path&gt;) with the path to the .img file, and that the device name specified in output file\u2019s argument (of=\/dev\/&lt;sd_name&gt;) is correct. For example: sudo dd bs=1m if=\/home\/YourName\/Download\/udoo-neo-udoobuntu.img of=\/dev\/rdisk3 Once dd has been completed, run: sudo sync The Micro SD card is now ready to be used. Simply insert it in the board\u2019s Micro SD Card slot and boot the system. If you have problems, have a look to the video tutorial Creating a bootable MicroSD card with Linux Ubuntu from image.","tags":"","url":"Getting_Started\/Create_a_bootable_MicroSD_card_for_UDOO_Neo.html"},{"title":"Use as a headless IoT Device","text":"What is a headless device and why do I want to use my NEO this way? Typically a headless device is a computer that is used without the need of monitor, keyboard and mouse. Typical examples of this configuration include: Web Servers; Network Attached Storage (NAS); Internet of Things Gateway or sensors; Rovers or Drones. These configurations are pretty common and they are required when space and mobility are the first concerns. To use your UDOO Neo in such ways you have plenty of options. USB Headless Device This mode is particularly handy if you don't have any available network or if you wish to use your NEO with your computer, for example at hackatons. Thanks to its integrated USB Tethering module, UDOO NEO will create a USB Network Upon Connection with your computer. To achieve this: Insert your Micro SD Card; Connect the Micro USB Cable to UDOO NEO and then to your PC: UDOO NEO will take its power from USB port; If its the first time you proceed this way, configure your PC as described in the configure Usb Direct Connection; Done! Your UDOO NEO is available at the address 192.168.7.2; You can use it via SSH Remote Terminal, VNC Remote Desktop or through Web Control Panel. Network Connected Headless Device Insert your Micro SD Card; Connect to your Network via Ethernet Cable; Turn on by applying power, either via Micro USB or DC-in. Your UDOO NEO will be available in your Network. You can now use it using SSH Remote Terminal, VNC Remote Desktop or through the Web Control Panel. Wireless Network Connected Headless Device This mode is exactly the same as the one above, except that you use the integrated Wireless Network adapter. Please note that you must configure your Wireless Network accordingly. You can do it either via the Web Control Panel or via Network Manager.","tags":"","url":"Getting_Started\/Use_as_a_headless_IoT_Device.html"},{"title":"Use as a Lightweight Desktop PC","text":"A common scenario is using UDOO NEO as a lightweight Desktop PC, with mouse, keyboard and monitor attached. This configuration is typical for: Computer Labs \\ Physical Computing Labs; Development Stations; Low Cost Desktop Replacement. Heads up! UDOO NEO is a single board computer meant for DIY electronics. Although it's not its main use case, UDOO NEO can still be used as a Desktop PC replacement if you don't have anything more suitable. Anyway, the performance of UDOO NEO is limited and you cannot expect it to match the capabilities of your ordinary Desktop PC. UDOO NEO lacks accelerated hardware video decoding, thus watching videos on UDOO NEO is not a satisfying experience. The GUI also doesn't support some important feature for browsing that you may be used to. The UDOO Team is aware of this limited capability and wants to inform you before hand. Typical Configuration, what is needed: Keyboard and Mouse Micro HDMI to HDMI Cable (or adapter) Power Supply Micro SD Card HDMI Monitor A USB hub is stronly suggested Set Up Insert the UDOObuntu Micro SD Card; Connect keyboard and mouse directly or through USB Hub; Connect the Micro HDMI cable or adapter; If any, plug the ethernet cable; Turn on UDOO NEO by plugging a 12v Supply (in this configuration at least 2A is suggested).","tags":"","url":"Getting_Started\/Use_as_a_Lightweight_Desktop_PC.html"},{"title":"Use as an Arduino","text":"All the UDOO Neo board versions are equipped with a NXP\u00ae iMX 6SoloX processor, which embeds on single chip an ARM Cortex-A9 and an ARM Cortex-M4 microcontroller. The Cortex-M4 allows easy access to a full-stack Arduino\u2122 environment To develop sketches for Arduino\u2122 M4 cores we provide the same way to program Arduino\u2122 Uno. You can use the internal Arduino\u2122 IDE preinstalled on UDOObuntu 2 running on the Cortex-A9 core of UDOO NEO, or connect the board and use the Arduino\u2122 IDE running on external PC. Overview Take a look at the Arduino M4 Processor section to find all the information about the Arduino\u2122 side of the UDOO NEO. Internal Arduino IDE Follow the guide Programming Arduino M4 from Internal Processor(Cortex-A9) to load a sketch on the Arduino M4 Processor from the Arduino\u2122 IDE preinstalled on UDOOBuntu 2. External Arduino IDE Follow the guide Programming Arduino M4 Processor from External PC to load a sketch on the Arduino M4 Processor from the Arduino\u2122 IDE installed on your External PC. Heads up!A microSD with a with UDOOBuntu2 have to be up and running to program the Arduino\u2122 M4 from an external PC. Communication and examples To learn more about the communication between the two SoloX cores take a look to the Communication section. You can find some example of how to make two software communicate through the two SoloX cores in the Serial Libraries section.","tags":"","url":"Getting_Started\/Use_as_an_Arduino.html"},{"title":"Usb Direct Connection","text":"What is USB Direct Connection UDOO NEO's Micro USB port can be used both to power up the board and to connect it to our computer. Connecting UDOO NEO to your computer will result in: UDOO NEO powering on, taking power from its USB Port A storage device will be available, containing UDOO NEO'S Kernel and DTB files, together with an offline documentation and quick start guide UDOO NEO will establish a network connection with your Computer, allowing to use it in headless mode In order to use UDOO NEO'S USB Connection on Mac and Windows, you must install few drivers first as described below: Enable USB Direct Connection: Installing Drivers Choose your OS to install the proper driver to make the USB Direct Connection works. Linux Windows Mac OS X Linux doesn't need a specific driver installation to make USB connection work properly. Everything should work out-of-the-box. Connect UDOO NEO via Micro USB Cable to PC, eventually you'll get the following message: Right click on Computer and select Manage. From System Tools, select Device Manager. It will show a list of devices currently connected with the development PC. In the list, RNDIS Kitl can be seen with an exclamation mark implying that driver has not been installed. Right click on it and select Update Driver Software... When prompted to choose how to search for device driver software, choose Browse my computer for driver software. Browse for driver software on your computer will come up. Select Let me pick from a list of device drivers on my computer. A window will come up asking to select the device type. Select Network adapters, as RNDIS emulates a network connection. In the Select Network Adapter window, select Microsoft Corporation from the Manufacturer list. Under the list of Network Adapter:, select Remote NDIS compatible device. The RNDIS Kitl device is now installed and ready for use. Install both of these drivers: Serial HoRNDIS Network: download and install the proper driver for your Mac OS X version from the official page. Reboot your MAC UDOO NEO will be available at 192.168.7.2 Use USB Direct Connection to control UDOO NEO Upon successful connection, UDOO NEO will be available at the address 192.168.7.2 You can establish a SSH Remote Terminal using the address 192.168.7.2 with credentials user udooer and psw udooer You can establish a VNC Remote Desktop Session using the address 192.168.7.2 and port 5900 (192.168.7.2:5900). The default password is udooer. You can configure UDOO NEO via the Web Control Panel directly from your browser. Troubleshooting If your UDOO NEO doesn't appear as a mass storage or is not recognized by your MAC\\Pc, this may be due to insufficient power output from the USB port it is attached to. Therefore, try to: Change the USB port it is plugged into, to be on the safe side plug UDOO NEO to USB 3.0 If you're on a Laptop, disable USB Power Saving mode Try to use a powered USB HUB","tags":"","url":"Basic_Setup\/Usb_Direct_Connection.html"},{"title":"Web Control Panel","text":"The UDOO Neo's Web Control Panel is a utility designed to: Easily configure your UDOO Neo, from the Wireless Connection to the UDOO Neo's hostname; Check its connection status; Learn how to develop basic projects; Test simple Arduino sketches on the fly; Expose the Documentation; How to connect to the UDOO Neo Web Control Panel Once you followed the USB Direct Connection guide and installed all the necessary drivers you can connect to the UDOO Neo Web Control Panel through one of these ways: connect UDOO Neo to your computer via USB, then open a browser on your computer and type 192.168.7.2 open a browser and type the IP address of UDOO Neo if you know it and if Neo is connected to the same network of your host computer. open a browser and type udooneo.local. Beware to have installed Bonjour on your Windows computer. On Mac and Linux you should have what you need pre-installed: Bonjour on Mac OS and Avahi on Linux. N.B: This is a beta feature, thus we suggest to go for the first two methods. Dashboard The Dashboard gives you a quick insight on the status of your UDOO Neo: At the top, you'll find an overview of board's connectivity, indicating whether Ethernet, USB, Wlan and Bluetooth are connected, and their IP address; In the center, you can find board model and unique ID. On the right, there are axis and modulus values for the Accelerometer, Gyroscope and Magnetometer; The other tiles are the starting point on discovering UDOO Neo's capabilities. Arduino On this section you can try the integrated Arduino M4 Processor. You can upload two simple Hello World sketches, Fade and Blink (from the Samples section) or code your own sketch using th Web IDE. Ardublockly allows to build Arduino sketches graphically, interconnecting logic blocks, without writing any code. Configuration This section helps you to configure your board and connect it to a wireless network: On &quot;Password and hostname&quot;, you can change your passwords and set a name for your board; On &quot;Network settings&quot;, you can connect to Wi-Fi networks; On &quot;Regional settings&quot; you can set the locale, timezone and regional settings; On &quot;Advanced settings&quot; you can change the main video output device (e.g. HDMI or LVDS), enable\/disable the Arduino core and change the TCP port where the Web Control Panel operates (so you can, for example, install a webserver on your board, like Apache or nginx),","tags":"","url":"Basic_Setup\/Web_Control_Panel.html"},{"title":"Remote Terminal (SSH)","text":"Requirements A first condition to establish a SSH connection with your UDOO Neo is to have previously completed the tutorial about the USB Direct Connection. A second condition is to download and install an SSH Client for your system, like Putty Connection via SSH Once you have completed these steps, open your SSH client. For the sake of this example, we consider you're using PuTTY on Windows. Opening PuTTY a window will ask you to specify the destination you want to connect to. In the first blank space, named Host Name or IP address, type 192.168.7.2. Eventually, a Windows Firewall popup could appear the first time you do this. If this happens, allow PuTTY to bypass the firewall. When the connection succeeds, a black window will appear. That is the terminal. It will ask you to enter your login credential. Type udooer, then press &quot;Enter&quot;. A new line will appear: udooer@192.168.7.2's password: Type udooer (if you did not change your default password using the Web Control Panel yet, then press &quot;Enter&quot;. Do not worry if you don't see what you type in the terminal: it's an expedient to hide your password to eventual onlookers. At this point you can use your terminal: login as: udooer udooer@192.168.7.2's password: Welcome to Ubuntu 14.04.3 LTS (GNU\/Linux 3.14.56-udooneo-xxxxxxxxxx armv7l) * Documentation: https:\/\/www.udoo.org\/docs-neo\/ Last login: Thu Jan 1 10:22:30 1970 from 192.168.7.1 udooer@udooneo:~$ Good job, mate: you are now connected to your UDOO Neo via SSH.","tags":"","url":"Basic_Setup\/Remote_Terminal_(SSH).html"},{"title":"Remote Desktop (VNC)","text":"What you should do now is downloading a suitable VNC client, like VNC Viewer So, once downloaded just execute the program and install it. Then, open the program: a window will pop up. Assuming you connected to your UDOO Neo via the USB cable, type 192.168.7.2 in the VNC Server adddress, then press &quot;Connect&quot;. Then type your password (default password is udooer) and a new window will pop up in your desktop, that is the desktop of your UDOO Neo! Done!","tags":"","url":"Basic_Setup\/Remote_Desktop_(VNC).html"},{"title":"Serial Debug Console","text":"Overview UDOO Neo features a Serial Debug Console available on the external pinout which is very useful to have a complete debug console starting from the boot process. Connecting via serial will practically result in a shell console, the same as the one you\u2019ll obtain through SSH connection http:\/\/en.wikipedia.org\/wiki\/Secure_Shell. You can find a useful accessory in the UDOO shop to easy exploit the Serial Debug Console of UDOO Neo: the USB-to-TTL\/Serial Debug Module for UDOO NEO. The Serial Debug Console is available through UART 1 over the external pinout header J7 on two pins, 46 and 47 (PCB names). You can find more info useful to locate the pins in the UART Serial Ports section. If you haven't the official UDOO NEO accessory module you can use a any other standard USB-to-TTL\/Serial dongle available in the market. Connecting via Serial Choose the OS you use. Windows Mac OS X Linux Connecting via Serial from Windows Download the serial adapter Driver. For the official USB-to-Serial debug module for UDOO NEO you can find the Driver in the Silabs page: Install the proper version for your Operating system (Check how to define your Windows version): CP210xVCPInstaller_x86.exe for 32-bit systems CP210xVCPInstaller_x64.exe for 64-bit system Download and install a software to manage the serial like Putty Open Putty and configure it as follow: Connection type: serial Port: COM3 (please note that this value may be different, check the number of the COM assigned in Windows Device Manager) Speed: 115200 Save it the configuration as Udoo-serial for future uses. Click Open You\u2019re in! You\u2019ll be able to see the startup process and access to the remote shell console on UDOO NEO.","tags":"","url":"Basic_Setup\/Serial_Debug_Console.html"},{"title":"UDOObuntu","text":"UDOObuntu is the official Linux-based operating system for the UDOO Neo. Technical specifications UDOObuntu 2 is based on Ubuntu 14.04. It is provided in two flavours: without any GUI (ideal for headless installations) with a full LXDE desktop environment Both images can be downloaded from the image section of the website. Besides the Ubuntu 14.04 specifications, UDOObuntu differs for the following elements: Linux kernel version 3.14.56 GPU accelerated Xorg 1.15 Arduino IDE 1.6.5 Chromium browser 48, with WebGL enabled gstreamer, which plays full HD videos via gplay QT 5.2.1 with X11 OpenGL ES2 GPU acceleration Web Control Panel Device Tree Editor, to control pinmuxing Updates The distribution uses the official Ubuntu repository and the UDOO repository, so it is possible to update a running system via sudo apt update sudo apt dist-upgrade Installation Instructions to download and flash the SD card image are available on this page. Default passwords The default user account is named udooer, and its password is udooer. The root password is ubuntu. Under the hood The UDOObuntu image available on UDOO website is a full image of an SD card with the following partition scheme: 1MB of reserved storage for the boot-loader (SPL, executable and environment variables) 32MB FAT partition, mounted in \/boot, which contains kernel, device trees and the documentation an EXT4 partition, mounted in \/, the root filesystem The root partition is automatically expanded at the first boot to the size of the SD card. Development UDOObuntu image is generated automatically from the build script mkudoobuntu. This tool builds recipes for different boards and image types (eg. with GUI or headless). The first step is to debootstrap a base Ubuntu armhf system. Then some configuration files are patched and UDOO specific packages are installed from the UDOO repository.","tags":"","url":"Software_Operating_Systems\/UDOObuntu.html"},{"title":"Android","text":"Android has been ported to UDOO Neo. Technical specifications Android for UDOO Neo is based on Android 5.1 SD card images can be downloaded from the image section of the website. Installation Instructions to download and flash the SD card image are available on this page. Development Instructions to download and compile the Android Source code for UDOO NEO are available on the Compile Android From Source section.","tags":"","url":"Software_Operating_Systems\/Android.html"},{"title":"Yocto","text":"Yocto is an unofficial distribution for UDOO boads. It is developed maintained by the community, almost entirely by Christian Ege who also started the porting of Yocto for UDOO boards. For problems you may encounter with this distribution your go-to place is the Yocto Subforum in UDOO Forum Also, Christian Ege is aso a user of the UDOO Forum, as well as admin of the Yocto Subforum. What is Yocto The Yocto Project is a Linux Foundation workgroup whose goal is to produce tools and processes that will enable the creation of Linux distributions for embedded software that are independent of the underlying architecture of the embedded software itself. The project was announced by the Linux Foundation in 2010. In March 2011, the project aligned itself with OpenEmbedded, an existing framework with similar goals, with the result being The OpenEmbedded-Core Project. The Yocto Project is an open source project whose focus is on improving the software development process for embedded Linux distributions. The Yocto Project provides interoperable tools, metadata, and processes that enable the rapid, repeatable development of Linux-based embedded systems. Project Scope The Yocto Project has the aim and objective of attempting to improve the lives of developers of customised Linux systems supporting the ARM, MIPS, PowerPC and x86\/x86 64 architectures. A key part of this is an open source build system, based around the OpenEmbedded architecture, that enables developers to create their own Linux distribution specific to their environment. This reference implementation of OpenEmbedded is called Poky. There are several other sub-projects under the project umbrella which include EGLIBC, pseudo, cross-prelink, Eclipse integration, ADT\/SDK, the matchbox suite of applications, and many others. One of the central goals of the project is interoperability among these tools. The project offers different sized targets from &quot;tiny&quot; to fully featured images which are configurable and customisable by the end user. The project encourages interaction with upstream projects and has contributed heavily to OpenEmbedded-Core and BitBake as well as to numerous upstream projects, including the Linux kernel.[citation needed] The resulting images are typically useful in systems where embedded Linux would be used, these being single-use focused systems or systems without the usual screens\/input devices associated with desktop Linux systems. As well as building Linux systems, there is also an ability to generate a toolchain for cross compilation and a software development kit (SDK) tailored to their own distribution, also referred to as the Application Developer Toolkit (ADT). The project tries to be software and vendor agnostic. Thus, for example, it is possible to select which package manager format to use (deb, rpm, or ipk). Within builds, there are options for various build-time sanity\/regression tests, and also the option to boot and test certain images under QEMU to validate the build. UDOO Neo Here you can find the Open Embedded meta-layer for UDOO boards. Follow the instructions in the README of the github project to know how to use it. Thanks to graugans for his work.","tags":"","url":"Software_Operating_Systems\/Yocto.html"},{"title":"Motion sensors","text":"UDOO Neo is equipped with 9-axis motion sensors: accelerometer, magnetometer and gyroscope. Accelerometer and magnetometer are embedded on the same Freescale chip, that is FXOS8700CQ, the gyroscope is a single FXAS21002C chip. They communicate with i.MX 6SoloX over I2C bus number 4. They can be accessed by M4 core and also by A9 core. They can be used in ping mode, asking the values to the sensors, or in interrupt mode. Heads up! Only EXTENDED and FULL board versions are equipped with embedded motion sensors. FXOS8700CQ - Accelerometer\/Magnetometer FXOS8700CQ is a small, low-power, 3-axis, linear accelerometer and 3-axis, magnetometer combined into a single package. The device features an I2C with 14-bit accelerometer and 16-bit magnetometer ADC resolution along with smart-embedded functions. FXOS8700CQ has dynamically selectable acceleration full scale ranges of \u00b12g \/ \u00b14g \/\u00b18g and a fixed magnetic measurement range of \u00b11200\u03bcT. Output data rates (ODR) from 1.563 Hz to 800 Hz are selectable by the user for each sensor. Interleaved magnetic and acceleration data is available at ODR rates of up to 400 Hz. FXOS8700CQ is guaranteed to operate over the extended temperature range of -40 \u00b0C to +85 \u00b0C. I2C address: 0x1E Download datasheet Read acceleration and magnetic field data To enable the accelerometer, you need to write 1 in the file below: echo 1 &gt; \/sensors\/accelerometer\/enable Heads up!In Udoobuntu versions higher or equals than 2 this sensor is enabled by default! Accelerometer data is then available reading the file \/sensors\/accelerometer\/data. To enable the magnetometer, you need to write 1 in the file below: echo 1 &gt; \/sensors\/magnetometer\/enable Heads up!In Udoobuntu versions higher or equals than 2 this sensor is enabled by default! Magnetometer data is then available reading the file \/sensors\/magnetometer\/data. FXAS21002 - Gyroscope 3-Axis Digital Angular Rate Gyroscope FXAS21002C is a small, low-power, yaw, pitch, and roll angular rate gyroscope with 16 bit ADC resolution. The full-scale range is adjustable from \u00b1250\u00b0\/s to \u00b12000\u00b0\/s. It features I2C interface. FXAS21002C is capable of measuring angular rates up to \u00b12000\u00b0\/s, with output data rates (ODR) from 12.5 to 800 Hz. An integrated Low-Pass Filter (LPF) allows the host application to limit the digital signal bandwidth. The device may be configured to generate an interrupt when a user-programmable angular rate threshold is crossed on any one of the enabled axes. FXAS21002C is guaranteed to operate over the extended temperature range of \u201340 \u00b0C to +85 \u00b0C I2C address: 0x20 Download datasheet Read angular speed data To enable the gyroscope, you need to write 1 in the file below: echo 1 &gt; \/sensors\/gyroscope\/enable Heads up!In Udoobuntu versions higher or equals than 2 this sensor is enabled by default! Gyroscope data is then available from reading the file \/sensors\/gyroscope\/data. Examples Accelerometer examples Bash PHP #!\/bin\/bash echo 1 &gt; \/sensors\/accelerometer\/enable cat \/sensors\/accelerometer\/data # it will print something like: # -6948,344,-14472 &lt;?php file_put_contents(&quot;1&quot;, &quot;\/sensors\/accelerometer\/enable&quot;); $data = trim(file_get_contents(&quot;\/sensors\/accelerometer\/data&quot;)); $axis = explode(&quot;,&quot;, $data); echo &quot;X=&quot; . $axis[0] . &quot; Y=&quot; . $axis[1] . &quot; Z=&quot; . $axis[2] . PHP_EOL; echo &quot;Modulus=&quot; . sqrt($axis[0]*$axis[0] + $axis[1]*$axis[1] + $axis[2]*$axis[2]) . PHP_EOL; \/\/ it will print something like: \/\/ X=688 Y=-480 Z=-16436 \/\/ Modulus=16457.394690533 Magnetometer examples Bash PHP #!\/bin\/bash echo 1 &gt; \/sensors\/magnetometer\/enable cat \/sensors\/magnetometer\/data # it will print something like: # -225,257,1372 &lt;?php file_put_contents(&quot;1&quot;, &quot;\/sensors\/magnetometer\/enable&quot;); $data = trim(file_get_contents(&quot;\/sensors\/magnetometer\/data&quot;)); $axis = explode(&quot;,&quot;, $data); echo &quot;X=&quot; . $axis[0] . &quot; Y=&quot; . $axis[1] . &quot; Z=&quot; . $axis[2] . PHP_EOL; echo &quot;Modulus=&quot; . sqrt($axis[0]*$axis[0] + $axis[1]*$axis[1] + $axis[2]*$axis[2]) . PHP_EOL; \/\/ it will print something like: \/\/ X=-412 Y=-414 Z=1348 \/\/ Modulus=1469.0963208721 Gyroscope examples Bash PHP #!\/bin\/bash echo 1 &gt; \/sensors\/gyroscope\/enable cat \/sensors\/gyroscope\/data # it will print something like: # 12,8,4 &lt;?php file_put_contents(&quot;1&quot;, &quot;\/sensors\/gyroscope\/enable&quot;); $data = trim(file_get_contents(&quot;\/sensors\/gyroscope\/data&quot;)); $axis = explode(&quot;,&quot;, $data); echo &quot;X=&quot; . $axis[0] . &quot; Y=&quot; . $axis[1] . &quot; Z=&quot; . $axis[2] . PHP_EOL; echo &quot;Modulus=&quot; . sqrt($axis[0]*$axis[0] + $axis[1]*$axis[1] + $axis[2]*$axis[2]) . PHP_EOL; \/\/ it will print something like: \/\/ X=19 Y=13 Z=3 \/\/ Modulus=23.2163735 Direct I2C register access It' also possible to read direcly from I2C register. However, for novice users we suggest to use previous methods. Read accelerometer\/magnetometer data via I2C #!\/bin\/sh # set to active mode i2cset -f -y 3 0x1e 0x2a 1 # enable both accelerometer and magnetometer i2cset -f -y 3 0x1e 0x5b 3 while [ 1 ]; do # accelerometer vector a_x=$(( $( i2cget -f -y 3 0x1e 0x01 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x1e 0x02 ) )) a_y=$(( $( i2cget -f -y 3 0x1e 0x03 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x1e 0x04 ) )) a_z=$(( $( i2cget -f -y 3 0x1e 0x05 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x1e 0x06 ) )) # magnetometer vector m_x=$(( $( i2cget -f -y 3 0x1e 0x33 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x1e 0x34 ) )) m_y=$(( $( i2cget -f -y 3 0x1e 0x35 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x1e 0x36 ) )) m_z=$(( $( i2cget -f -y 3 0x1e 0x37 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x1e 0x38 ) )) echo &quot;acc: $a_x\/$a_y\/$a_z - mag: $m_x\/$m_y\/$m_z&quot; done Read gyroscope via I2C #!\/bin\/sh # set to active mode i2cset -f -y 3 0x20 0x13 0x16 while [ 1 ]; do # gyro vector g_x=$(( $( i2cget -f -y 3 0x20 0x01 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x20 0x02 ) )) g_y=$(( $( i2cget -f -y 3 0x20 0x03 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x20 0x04 ) )) g_z=$(( $( i2cget -f -y 3 0x20 0x05 ) &lt;&lt; 8 | $( i2cget -f -y 3 0x20 0x06 ) )) echo &quot;$g_x\/$g_y\/$g_z&quot; done Use motion sensors from Arduino M4 core By default 9-axis motion sensors are connected to A9 core and you can manage by Linux drivers or I2C tools as explainend previously. To allow to M4 Arduino core to access these sensors we need to change internal pinmuxing. Udoobuntu provides a graphical tool to change this configuration. From start menu runs Preferences --&gt; Device Tree Editor Insert the root password ( udooer by default ) The tool shows all the A9 pins and their functions. By default the i2c4 channel is highlighted and it means that is assigned ti A9. Right click on the pins and select remove After that the i2c4 pins are not highlighed Click on save button on the top bar. Click ok, close the browser and reboot the board. For an example sketch of how to catch data from the motion sensors through Arduino M4 go to the Controlling 9-axis motion sensors section.","tags":"","url":"Hardware_Accessories\/Motion_sensors.html"},{"title":"Bricks snap in sensors","text":"Introduction By default the the I2C-1 Bus connected to the Brick connector of UDOO NEO is assigned to Cortex-A9 core and it\u2019s possible to control them by Linux driver. If you would use Bricks from the Arduino\u2122 core Cortex-M4 take a look at Introduction to Pinmuxing. Barometer Brick - MPL3115A2 Here you can find documentation as datasheet, schematics, and montage plane in the Other Resurces page of our website, in the Accessories tab. Usage Barometer Brick is able to return Temperature and Pressure ambient values. In this file you can find the temperature scale (the sensor resolution): \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_temp_scale In this file you can find the temperature integer raw value (to be multiplied for the above-mentioned resolution): \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_temp_raw In this file you can find the pressure scale (the sensor resolution): \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_pressure_scale In this file you can find the pressure integer raw value (to be multiplied for the above-mentioned resolution): \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_pressure_raw Heads up! If you turn off the M4 the device name can change to \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio:device2 Barometer example This example reads data from the Brick sensor and prints the temperature and pressure on the console: #!\/bin\/bash while [ 1 ]; do echo -n 'temp: ' TEMP_RAW=`cat \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_temp_raw` TEMP_SCALE=`cat \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_temp_scale` python &lt;&lt; EOF print( $TEMP_RAW * $TEMP_SCALE ) EOF echo -n 'pressure: ' PRES_RAW=`cat \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_pressure_raw` PRES_SCALE=`cat \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0060\/iio\\:device0\/in_pressure_scale` python &lt;&lt; EOF print( $PRES_RAW * $PRES_SCALE ) EOF done Linux kernel support If you plan to use this Brick sensor with a custom kernel, be sure to build the following module: Device Driver -&gt; -&gt; Industrial I\/O support -&gt; Pressure Sensors -&gt; Freescale MPL3115A2 pressure sensor Driver And declare the sensor in the device-tree too: &amp;i2c2 { clock-frequency = &lt;100000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_i2c2_1&gt;; status = &quot;okay&quot;; barometer: mpl3115@60 { compatible = &quot;fsl,mpl3115&quot;; reg = &lt;0x60&gt;; }; }; Connection at boot If the sensor is already connected at boot the kernel automatically recognizes the sensor. If you connect the sensor when UDOOBuntu already booted, you need to restart the module: sudo rmmod mpl3115 sudo modprobe mpl3115 Temperature Brick - TMP75b Here you can find documentation as datasheet, schematics, and montage plane in the Other Resurces page of our website, in the Accessories tab. Usage Enable the sensor via the following command: sudo sh -c 'echo lm75 0x48 &gt; \/sys\/class\/i2c-dev\/i2c-1\/device\/new_device' (sudo sh -c is required to execute a command as root user) In this file there is the temperature value in milli-degree Celsius: \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0048\/temp1_input Temperature example This example reads data from the Brick sensor and prints the temperature on the console: #!\/bin\/bash while [ 1 ]; do cat \/sys\/class\/i2c-dev\/i2c-1\/device\/1-0048\/temp1_input done Linux kernel support If you plan to use this Brick sensor with a custom kernel, be sure to build the following module: Device Drivers ---&gt; Hardware Monitoring support ---&gt; &lt;M&gt; National Semiconductor LM75 and compatibles And declare the sensor in the device-tree too: &amp;i2c2 { clock-frequency = &lt;100000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_i2c2_1&gt;; status = &quot;okay&quot;; lm75: lm75@48 { \/\/ Brick Temperature Sensor compatible = &quot;national,lm75&quot;; reg = &lt;0x48&gt;; }; }; Connection at boot If the sensor is already connected at boot the kernel automatically recognizes the sensor. If you connect the sensor when UDOOBuntu already booted, you need to restart the module: sudo rmmod lm75 sudo modprobe lm75 I2C Snap-in connector for UDOO Bricks","tags":"","url":"Hardware_Accessories\/Bricks_snap_in_sensors.html"},{"title":"GPIO","text":"GPIO The GPIO (General-Purpose Input\/Output) peripheral provides dedicated general-purpose pins that can be configured as either inputs or outputs. When configured as an output, it is possible to write to an internal register to control the state driven on the output pin. When configured as an input, it is possible to detect the state of the input by reading the state of an internal register. In addition, the GPIO peripheral can produce CORE interrupts. The GPIO is one of the blocks controlling the IOMUX of the chip. More detailed information are available on the Chapter 30 of the iMX 6SoloX Reference Manual. How to access GPIOs from Linux The GPIOs available from the Linux kernel are placed on the external pinout headers (in orange). The internal pinout is assigned to the M4 core (blue pins), the external one to the A9 core. Heads up! Disable the M4 core to give A9 control over the inner row (refer to this guide on how to do that). Pinmuxing Most of the pins are exported by default as GPIO; however the UDOO Neo CPU is able to assign more specialized tasks to the external pins. In the following two images it is reported a list of all the possible behaviours: To change this configuration, please follow this guide. Using GPIOs By default (for safety reasons), all GPIOs are exported in input configuration. This means the board CPU can read the value of the voltage connected to the pins. The other possible configuration is output, which forces a pin to take a specific voltage. Heads up! When using the output configuration, be sure to avoid short-circuits! It is possible to switch a pin in input or output mode with the following commands: # set pin 25 to input echo in &gt; \/gpio\/pin25\/direction # set pin 25 to output echo out &gt; \/gpio\/pin25\/direction To verify the voltage direction, just read the same file: cat \/gpio\/pin25\/direction Write values To write a low or high value on a GPIO, you need to write 0 or 1 in the value file: # set GPIO 25 to low value - 0 volts echo 0 &gt; \/gpio\/pin25\/value # set GPIO 25 to high value - 3.3 volts echo 1 &gt; \/gpio\/pin25\/value In order to set the value, the GPIO must be in the out direction. Read values If the direction is set to in, it is possible to read the GPIO value reading the same file: cat \/gpio\/pin25\/value If the direction is set to out and you try to read the value, is not guaranteed that the value is coherent with the voltage found on the external pinout. Advanced usage GPIO management is made simple by the udoo-gpio-export package, which comes preinstalled in UDOObuntu Linux. This package takes care of exporting all GPIOs in input mode, and creates the symlinks from the \/sys\/class\/gpio entries to the \/gpio directory. If you want, you can directly use the \/sys\/class\/gpio entries. For example, to export a GPIO use: echo GPIO_NUMBER &gt; \/sys\/class\/gpio\/export Please note that GPIO_NUMBER is not the number written on the PCB. Instead, it is the number written in the round label close to the PCB number in the previous two images. For example, if you want to control the pin 24 (PCB name) you should read GPIO_25. GPIO_NUMBER can be calculated with the following relation: GPIO_NUMBER = ((BANK - 1) * 32 ) + ID For example, if you want to export the GPIO1_IO_25; # GPIO1_IO_25 means BANK=1 and ID=25 # GPIO_NUMBER = ((1 - 1) * 32 ) + 25 = 25 echo 25 &gt; \/sys\/class\/gpio\/export","tags":"","url":"Hardware_Accessories\/GPIO.html"},{"title":"UART serial ports","text":"Universal Asynchronous Receiver\/Transmitter (UART) provides serial communication capability with external devices through a level converter and an RS-232 cable or through the use of external circuitry that converts infrared signals to electrical signals (for reception) or transforms electrical signals to signals that drive an infrared LED (for transmission) in order to provide low speed IrDA compatibility. To see more detailed information look at the Chapter 65 on the iMX 6SoloX Reference Manual. UDOO Neo UART ports Table below gives a short description of the UART ports: Name Function Description UART_1 Cortex A9 serial debug On this serial it's possible to have access to a Linux console UART_2 Cortex M4 MQX debug Freescale MQX real-time OS library uses this serial for debug info UART_3 WL1831 Bluetooth chip Used to communicate with Bluetooth chip mounted on the board UART_4 n.c. n.a. UART_5 Arduino pin 0 \/1 serial It can be used by M4 microcontroller through the Serial0 object UART_6 Cortex A9 user serial Not enabled by default. It can be enabled on external A9 pinout Debug UART ports The serial debug ports (UART_1 and UART_2) are available on the external pinout. Signals can be accessed with a USB to TTL adapters. UART 1 This UART is assigned to the A9 core as Debug Serial port. Over this serial it is possible to access a terminal console to login on a Linux shell. It can be accessed over the external pinout on the following pins: PCB NAME SCHEMATICS SIGNAL NAME SCHEMATIC IMX6 PAD NAME REFERENCE MANUAL Pad Mux Register ALTERNATE UART_1_TX 47 UART1_TXD GPIO_4 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04 ALT0 - UART1_TX_DATA UART_1_RX 46 UART1_RXD GPIO_5 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05 ALT0 - UART1_RX_DATA Default configuration Baudrate: 115200 Data: 8 bit Parity: none Stop: 1 bit Flow control: none Kernel device name: \/dev\/ttymxc0 UART 2 This serial is controlled by the M4 core. This core runs code based on MQX real time OS\/libraries. These are a set of libraries developed by Freescale. They can exploit at best the M4 architecture, avoiding a raw port of Arduino libraries. The UART_2 port is used for debug purposes. It can be accessed over the external pinout on the following pins: PCB NAME SCHEMATICS SIGNAL NAME SCHEMATIC IMX6 PAD NAME REFERENCE MANUAL PAD NAME ALTERNATE UART_2_TX 45 UART2_TXD GPIO_6 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06 ALT0 - UART2_TX_DATA UART_2_RX 44 UART2_RXD GPIO_7 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07 ALT0 - UART2_RX_DATA Default configuration Baudrate: 115200 Data: 8 bit Parity: none Stop: 1 bit Flow control: none No kernel device (the kernel can't access this serial) UART 3 This UART is connected to the Texas Instruments WL1831 chip for Bluetooh data communication purposes. It uses four signals at 1.8 Volts: RX TX CTS RTS Kernel device name: \/dev\/ttymxc2 PCB NAME SCHEMATICS SIGNAL NAME SCHEMATIC IMX6 PAD NAME REFERENCE MANUAL PAD NAME ALTERNATE UART_3_TX - BT_HCI_TX_1V8 SD3_DAT4 IOMUXC_SW_MUX_CTL_PAD_SD3_DATA4 ALT3 - UART3_RX_DATA UART_3_RX - BT_HCI_RX_1V8 SD3_DAT5 IOMUXC_SW_MUX_CTL_PAD_SD3_DATA5 ALT3 - UART3_TX_DATA UART_3_RTS - BT_HCI_RTS_1V8 SD3_DAT6 IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6 ALT3 - UART3_RTS_B * UART_3_CTS - BT_HCI_CTS_1V8 SD3_DAT7 IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7 ALT3 - UART3_CTS_B * * For these two signals the iMX 6Solox processor works in DCE mode. UART 5 This is the serial controlled by the M4 core, available on the pins 0 and 1 on the external pinout. In the Arduino IDE you can access to this UART using the object Serial0. Serial0.begin(115200); \/\/ Init the Serial at 115200 baudrate Serial0.available(); \/\/ get the number of incoming bytes Serial0.read(); \/\/ get the first byte in FIFO buffer Serial0.write(); \/\/ write on output buffer byte array Serial0.print(); \/\/ write on output buffer char array Serial0.println(); \/\/ write on output buffer char array plus newline char UART 6 This UART is user available, but it must be included in the device tree before the use. By default all of its pins are given to A9 in GPIO mode. Kernel device name: \/dev\/ttymxc5 PCB NAME SCHEMATICS SIGNAL NAME SCHEMATIC IMX6 PAD NAME REFERENCE MANUAL PAD NAME ALTERNATE UART_6_CTS_B 33 CSI0_DAT7 CSI0_DAT7 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA07 ALT4 - UART6_CTS_B UART_6_RTS_B 32 CSI0_DAT6 CSI0_DAT6 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA06 ALT4 - UART6_RTS_B UART_6_TX_DATA 31 CSI0_DAT5 CSI0_DAT5 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA05 ALT4 - UART6_TX_DATA UART_6_RX_DATA 30 CSI0_DAT4 CSI0_DAT4 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA04 ALT4 - UART6_RX_DATA UART_6_DCD_B 29 CSI0_DAT3 CSI0_DAT3 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA03 ALT4 - UART6_DCD_B UART_6_DTR_B 28 CSI0_DAT2 CSI0_DAT2 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA02 ALT4 - UART6_DTR_B UART_6_DSR_B 27 CSI0_DAT1 CSI0_DAT1 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA01 ALT4 - UART6_DSR_B UART_6_RI_B 26 CSI0_DAT0 CSI0_DAT0 IOMUXC_SW_MUX_CTL_PAD_CSI_DATA00 ALT4 - UART6_RI_B","tags":"","url":"Hardware_Accessories\/UART_serial_ports.html"},{"title":"I2C bus","text":"The I2C (Inter-IC) bus is a bi-directional, two-wire serial bus that provides a communication link between integrated circuits (ICs). Phillips introduced the I2C bus 20 years ago for mass-produced items such as televisions, VCRs, and audio equipment. Today, I2C is the de-facto solution for embedded applications. UDOO Neo I2C channels Freescale iMX 6SoloX has 4 I2C channels. In UDOO Neo all four channels are used with different functions available for the user. In the pictures below these functions are listed: I2C 1 The PMIC, JTAG and LVDS screen touch are connected to the first I2C bus. PMIC The PF3000 is a Power Management Integrated Circuit (PMIC) designed specifically for use with the Freescale i.MX 7 and i.MX 6SL\/SX\/UL application processors. With up to four buck converters, six linear regulators, RTC supply, and coin-cell charger, the PF3000 can provide power for a complete system, including applications processors, memory, and system peripherals. This device is powered by SMARTMOS technology. JTAG The pads to connect a JTAG debugger are embedded on board, placed on the bottom of the board. The connector is not present to reduce the used space and the costs. The JTAG connector uses this bus to exchange data. LVDS touch panel Most of the touch panels use the I2C standard to communicate touch coordinates. For example, the official 7 inches touch panel uses this protocol for the connection. External pins The I2C 1 bus is available also on the user-accessible pinout: HEADER SDA SDL J6 27 26 J11 10 9 I2C 2 Channel 2 is by default assigned to A9. It's possible to change this assignment following this guide. Snan-ip Bricks connector On the J10 connector it is possible to connect UDOO Bricks sensors to the I2C 2 bus. External pins The I2C 2 bus is available also on the user-accessible pinout: HEADER SDA SDL J6 15 14 J5 37 36 J10 3* 4* * These are not the PCB numbers but header numbers I2C 3 This channel is used to control the LCD to HDMI converter. It cannot be accessed from the user because it logic runs at 1.8 Volts. The I2C channel 3 is assigned to the A9 core only. LCD to HDMI converter iMX 6SoloX don't have the HDMI controller embedded on the SoC. So we need to use extra hardware to provide the HDMI video output. The TDA19988 chip is connected to the I2C 3. I2C 4 This channel is used to connect the 9-axis motion sensors. By default is connected to A9 core. Motion sensors The FXOS8700 (acc\/mag) and FXAS2100 (gyro) are connected to this channel. DEVICE FUNCTIONS I2C ADDRESS FXOS8700 Accelerometer \/ Magnetometer 0x1E FXAS2100 Gyroscope 0x20 Other devices can be connected on the external pins of this bus, paying attention to not make conflicts in the addresses. External pins The I2C signals are available on the external pinout: HEADER SDA SDL J6 33 32 J5 35 34","tags":"","url":"Hardware_Accessories\/I2C_bus.html"},{"title":"SPI bus","text":"The Serial Peripheral Interface bus (SPI) is a synchronous serial communication interface specification used for short distance communication, primarily in embedded systems. The interface was developed by Motorola and has become a de facto standard. Typical applications include sensors, Secure Digital cards, and liquid crystal displays. SPI devices communicate in full duplex mode using a master-slave architecture with a single master. The master device originates the frame for reading and writing. Multiple slave devices are supported through selection with individual slave select (SS) lines. ECSPI The Enhanced Configurable Serial Peripheral Interface (ECSPI) is a full-duplex, synchronous, four-wire serial communication block. The ECSPI contains a 64 x 32 receive buffer (RXFIFO) and a 64 x 32 transmit buffer (TXFIFO). With data FIFOs, the ECSPI allows rapid data communication with fewer software interrupts. The figure below shows a block diagram of the ECSPI. Key features of the ECSPI include: Full-duplex synchronous serial interface Master\/Slave configurable Four Chip Select (SS) signals to support multiple peripherals Transfer continuation function allows unlimited length data transfers 32-bit wide by 64-entry FIFO for both transmit and receive data Polarity and phase of the Chip Select (SS) and SPI Clock (SCLK) are configurable Direct Memory Access (DMA) support Max operation frequency up to the reference clock frequency. The ECSPI supports the modes described in the indicated sections: Master Mode Slave Mode Low Power Modes UDOO Neo SPI channels UDOO Neo exposes 3 ECSPI channels: MISO MOSI CLOCK SS0 SS1 SS2 SS3 Default core at boot ECSPI_2 20 21 38 39 - - - A9 (gpio mode) ECSPI_3 18 \/ A1 * A0 * A4 * 19 \/ A5 * 21 20 - A9 (gpio mode) ECSPI_5 12 \/ 40 11 \/ 43 13 \/ 42 10 \/ 41 - - - M4 * Analogs pin can also be connected to A9 core using phisical signal mux 74VHC4053AFT (U12, U13). For more detailed information look at the Chapter 22 of the iMX 6SoloX Reference Manual. ECSPI 2 ECSPI 2 has only for signals (MISO, MOSI, SCLK and SS0); By default the ECSPI 2 signals are assigned to A9 in GPIO mode. In order to enable ECSPI, follow this guide. ECSPI 3 ECSPI 3 is a full SPI, including Select Signals (SS0, SS1, SS2). ECSPI 5 ECSPI 5 has the same pin order, function, and position as Arduino UNO. By default it is assigned to the Arduino 101-compatible M4 core.","tags":"","url":"Hardware_Accessories\/SPI_bus.html"},{"title":"CAN bus","text":"A Controller Area Network (CAN bus) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other in applications without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles, but is also used in many other contexts. External pinout UDOO Neo exposes two ports on the external pinout: TX RX CAN_1 41 40 CAN_2 43 42 By default these pins are assigned to the A9 core, configured as GPIO. In order to use the pins for a CAN bus, they must be explicitly configured.","tags":"","url":"Hardware_Accessories\/CAN_bus.html"},{"title":"LVDS panels","text":"By default, UDOO Neo displays the graphical user interface on the micro-HDMI port. LVDS screens can be connected to the CN3 port. Before the screen can be used, it must be enabled as it follows. You cannot use the HDMI and the LVDS7 video outputs simultaneously. Warning! Make sure to plug the display cable when the board is turned off. Make sure you are powering your UDOO Neo with a 12V power supply when using LVDS screens. 7-inches LVDS panel The 7-inches UDOO LVDS screen is compatible with UDOO Neo. If you previously bought one for the UDOO Quad\/Dual, you just need to buy a new (smaller) cable and keep the same screen. Switch video output from HDMI to LVDS After you connect your LVDS screen to the CN3 connector, you must tell UDOO Neo to use the LVDS panel to draw the GUI. This can be done in several ways: Option 1: you have an HDMI monitor and mouse\/keyboard If you have an HDMI screen connected to UDOO Neo, open a terminal with the link on the desktop. Then you can switch the main video output from HDMI to LVDS7 by typing: sudo udooscreenctl set lvds7 (default password, if you did not change it, is udooer) You can revert this change by typing: sudo udooscreenctl set hdmi If you want more info about the udooscreenctl command visit the Set Video Output. If you prefer a graphical simple way to change the default video output, it is provided by the UDOO Web Control Panel in the &quot;Configuration&quot;-&gt;&quot;Advanced setting&quot; section. Option 2: you can connect via VNC or SSH If you can connect to your board via VNC or via SSH (using the USB, WiFi or Ethernet connection) , you can follow the steps explained in the previous section. Option 3: you have neither HDMI nor network If you cannot connect to your board via the network (VNC or SSH) and you have no HDMI screen, you can enable the LVDS display port editing a file in the UDOO Neo SD card. Put the flashed SD card in your computer. If your computer has no SD card reader, you can connect the UDOO Neo to your computer via the micro-USB port. A small FAT partition labelled boot will appear: Open the file named uEnv.txt contained in the partition. Heads up! The file must be saved with Unix-like line endings: Windows users can use the free Notepad++ text editor to safely edit the file. Mac OS X users can use the free TextWrangler text editor to safely edit the file. Linux users can use their favourite text editor (gedit, vim, nano) without concerns. Open the file and you will find this line: video_output=hdmi Substitute the word hdmi with lvds7: video_output=lvds7 Save the file, eject the boot partition and restart the board.","tags":"","url":"Hardware_Accessories\/LVDS_panels.html"},{"title":"PWM","text":"Pulse Width Modulation is a modulation technique where a digital pin alternates high and low. It is possible to configure the period (how frequent should the output oscillate) and the duty cycly (how much should the output stay high). PWM signals can be used to: control LEDs brightness control colors on RGB LEDs control motors, like servos etc. Step 1: enable PWM outputs Enable the PWM features on the external pinout using the device tree editor. Step 2: configure the outputs Before configuring a PWM output, it is necessary to export it: echo 0 &gt; \/sys\/class\/pwm\/pwmchip0\/export Then set period and duty cycle. For example, to generate a 1kHz signal with 30% of duty cycle, use: echo 1000000 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/period echo 300000 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/duty_cycle Then enable the PWM output: echo 1 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/enable Possible values to be used period - The total period of the PWM signal (read\/write). Value is in nanoseconds and is the sum of the active and inactive time of the PWM. duty_cycle - The active time of the PWM signal (read\/write). Value is in nanoseconds and must be less than the period. enable - Enable\/disable the PWM signal (read\/write); 0 means disabled PWM settings generator Select the desired frequency and duty cycle: PWM frequency Duty cicle Generated code echo 123456789 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/period echo 987654321 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/duty_cycle","tags":"","url":"Hardware_Accessories\/PWM.html"},{"title":"ADC","text":"Turn off M4 core By default, ADC pins (A0-A5) are assigned to the M4 core, so they can be used by Arduino. If you want, you can use the ADC pins from Linux; however you must disable the M4 core. Follow this guide to disable the M4 core startup. Read ADC Data You can read ADC values from virtual files in the sysfs: \/sys\/bus\/iio\/devices\/ UDOO Neo has ADC banks, adc1 and adc2: adc1 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device0\/ adc2 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device1\/ The corresponding pin values are located in: A0 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage0_raw A1 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage1_raw A2 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage2_raw A3 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage3_raw A4 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device1\/in_voltage0_raw A5 -&gt; \/sys\/bus\/iio\/devices\/iio\\:device1\/in_voltage1_raw If you want to read the A0 pin numeric value, access its file: cat \/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage0_raw If you want the analogic value expressed in millivolts instead of int, you can multiply the in_voltageX_raw file for the in_voltage_scale file Example: read A0 The following examples read the A0 integer values, multiplies it for the ADC scale and prints the result to the console: Bash PHP Python raw=$(&lt;\/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage0_raw) scale=$(&lt;\/sys\/bus\/iio\/devices\/iio\\:device0\/in_voltage_scale) echo &quot;$raw * $scale&quot; | bc -l 3299.194333890 &lt;?php $raw = file_get_contents(&quot;\/sys\/bus\/iio\/devices\/iio:device0\/in_voltage0_raw&quot;); $scale = file_get_contents(&quot;\/sys\/bus\/iio\/devices\/iio:device0\/in_voltage_scale&quot;); echo $raw*$scale . PHP_EOL; raw = int(open(&quot;\/sys\/bus\/iio\/devices\/iio:device0\/in_voltage0_raw&quot;).read()) scale = float(open(&quot;\/sys\/bus\/iio\/devices\/iio:device0\/in_voltage_scale&quot;).read()) print raw*scale Precision Analog inputs have a 12 bit precision (from 0 to 4095)","tags":"","url":"Hardware_Accessories\/ADC.html"},{"title":"USB-to-TTL Serial Debug Module","text":"Overview The USB-to-TTL\/Serial Debug Module for UDOO NEO is compatible with UDOO Neo. This module provide two serial devices on USB, one for Cortex A9 (Linux\/Android) and one for Cortex M4(Arduino\u2122). You have to connect it to pinout header J7. You can find more info useful to locate the pins in the UART Serial Ports section. How to use To use the USB-to-TTL\/Serial Debug Module for UDOO NEO plug the module and follow the instructions in the Serial Debug Console section.","tags":"","url":"Hardware_Accessories\/USB_to_TTL_Serial_Debug_Module.html"},{"title":"I2S","text":"I\u00b2S (Inter-IC Sound), pronounced I-squared-S, is an electrical serial bus interface standard used for connecting digital audio devices together. It is used to communicate PCM audio data between integrated circuits in an electronic device. The I\u00b2S bus separates clock and serial data signals, resulting in a lower jitter than is typical of communications systems that recover the clock from the data stream. Alternatively I\u00b2S is spelled I2S (pronounced I-two-S) or IIS (pronounced I-I-S). Despite the name, it is unrelated to the bidirectional I\u00b2C bus. From Wikipedia. Pins The IMX6 SoC provides those pins for I2S: TXFS: Transmit Frame Select TXC: Transmit Bit Clock TXD: Transmit Data RXFS: Receive Frame Select RXC: Receive Bit Clock RXD: Receive Data TXFS TXC TXD RXFS RXC RXD Default core at boot AUD6 31 27 26 30 29 25 A9 (gpio mode) Example Thanks to the I\u00b2S bus we can use audio codecs, such as DACs, with our UDOO Neo enabling it via I2S. As an example, we had already set a ESS 9023 DAC card on that bus, so you can use it plug and play. Note: the RX Pins are not enabled (only out). To do so, just open the Device Tree Editor and enable the AUD pins. At the next reboot, you will see an audio card installed in ALSA (even if it's not plugged). # aplay -L ... ... sysdefault:CARD=imxaudioes9023 imx-audio-es9023, Default Audio Device dmix:CARD=imxaudioes9023,DEV=0 imx-audio-es9023, Direct sample mixing device dsnoop:CARD=imxaudioes9023,DEV=0 imx-audio-es9023, Direct sample snooping device hw:CARD=imxaudioes9023,DEV=0 imx-audio-es9023, Direct hardware device without any conversions plughw:CARD=imxaudioes9023,DEV=0 imx-audio-es9023, Hardware device with all software conversions To play simple audio WAV samples just use aplay. # aplay -D plughw:CARD=imxaudioes9023,DEV=0 sample.wav Playing WAVE 'sample.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo","tags":"","url":"Hardware_Accessories\/I2S.html"},{"title":"HDMI 7inch touch","text":"The 7inch HDMI\/USB Display\/Touch is now compatible also with UDOO NEO. By default, UDOO Neo displays the graphical user interface on the micro-HDMI port, but since the micro-HDMI is configured to work with quite all the monitor\/TV HDMI, to make this accessories work you need to substitute same files in your UDOObuntu distro. The 7inch HDMI\/USB Display\/Touch use: HDMI for the Display USB-to-microUSB to power up the Display and use the Touch input. Heads up! You need a micro-HDMI to HDMI cable or adapter to use the 7inch HDMI display. Preparation (optional) To support the 7inch HDMI\/USB Display\/Touch you need to use a file that set the proper resolution, timing and other parameters for this display. This new file will disable the original UDOObuntu file that supports default TV\/monitor displays. We suggest making a backup of all the hdmi related files in the \/boot\/dts directory. for f in \/boot\/dts\/imx6sx-udoo-neo-*hdmi*.dtb; do cp -- &quot;$f&quot; &quot;$f&quot;.bak; done If you want to come back work with a standard TV\/monitor you need to revert these files. Instructions Download the package from here: udoo-neo_7HDMItouch_dtbs.tar.gz sha1 checksum: cde95a301d58b86aa086743170fe0d7f8adcd7d2 Extract the udoo-neo_7HDMItouch_dtbs.tar.gz package inside the \/boot\/dts\/ folder of the UDOObuntu microSD, substituting the files inside. You can use this command: tar xzvf udoo-neo_7HDMItouch_dtbs.tar.gz -C \/boot\/dts\/ Check the value of the video_output variable in the file \/boot\/uEnv.txt. Need to be set as video_output=hdmi to work with the 7 inch HDMI Display. Connect the micro-HDMI to HDMI cable, the USB cable and turn on the backlight switch behind the display. Reboot the UDOO NEO now to work with the 7 inch HDMI Display.","tags":"","url":"Hardware_Accessories\/HDMI_7inch_touch.html"},{"title":"WiFi","text":"Texas Instruments WL1831 UDOO Neo uses the Texas Instruments WL1831 to provide the Wi-Fi and Bluetooth connectivity. TI\u2019s WiLink 8 modules are pre-certified and offer high throughput and extended range along with Wi-Fi and Bluetooth coexistence in a power-optimized design. WiLink8 General Features: WLAN With Integrated RF Front-End Module(FEM), Power Amplifier (PA), Crystal, Switches, Filters, Passives, and Power Management on a Single Module Efficient Direct Connection to Battery by Employing Several Integrated Switched Mode Power Supplies (DC-DC) Dual-Mode Bluetooth and Bluetooth Low Energy FCC, IC, and CE Certified With Chip Antenna Hardware Design Files and Design Guide available from TI HCI Transport for Bluetooth over UART and SDIO for WLAN Temperature Compensation Mechanism to Ensure Minimal Variation in RF Performance Over the Entire Temperature Range Commercial Modules Operating Temperature: \u201320\u00b0C to 70\u00b0C Small Form Factor: 13.4 \u00d7 13.3 \u00d7 2 mm More information are available on TI Wiki. Connecting to Wi-Fi networks You can connect to wireless networks by: using the Web Control Panel, in Configuration\/Network settings; using the network utility in the UDOObuntu desktop environment (in the bottom-right corner). Known issues iwconfig command not work Texas Instruments WL1831 driver doesn't support iwconfig command. Just use the iw command instead. This is the Official Ubuntu Reference","tags":"","url":"Wireless_Communication\/WiFi.html"},{"title":"WiFi SoftAP","text":"Newer builds of UDOObuntu are supporting the software access-point mode for the WL1831 chip. In order to enable SoftAP mode, install the udoo-softap metapackage: sudo apt-get install udoo-softap Doing this, a default \/etc\/hostapd\/hostapd.conf will be provided. Edit this file to change the access point settings: interface=wlan0 driver=nl80211 hw_mode=g macaddr_acl=0 auth_algs=1 ignore_broadcast_ssid=0 ieee80211n=1 ssid=UDOO hotspot channel=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=udooboard You should change: ssid is the name of the network; channel is the frequency channel (it is better to pick the channel least congested); wpa_passphrase is the password to connect to the network. In the file \/etc\/default\/hostapd uncomment the line DAEMON_CONF and set this value to the hostapd.conf path: DAEMON_CONF=&quot;\/etc\/hostapd\/hostapd.conf&quot; Heads up! When in Soft-AP mode, you cannot connect to wireless networks in client mode! In fact, installing udoo-softap you are disabling the wpa_supplicant service. Uninstall the Soft-AP metapackage to restore client Wi-Fi connectivity. Troubleshooting To check everything is working fine you can run the command: sudo service hostapd status If is says &quot;hostapd is not running&quot; check for possible issues using the command: sudo hostapd \/etc\/hostapd\/hostapd.conf Error: Could not configure driver mode If you encounter this problem, it is probably because the driver of hostapd is clashing with the drivers of network-manager utility. They are basically fighting to take charge of the wireless device you are trying to configure with hostapd. If you notice, when you put the card in monitor mode manually using the following commands: Note: All commands are being run as root ifconfig wlan0 down iwconfig wlan0 mode monitor ifconfig wlan0 up After a few seconds, the card jumps back to mode:managed This is because the card is being managed by network-manager utility. So, there are two ways you can tackle this issue: airmon-ng check kill to kill all the potentially troublesome processes, like network-manager, wpa_supplicant, dhclient Make your selected card an exception in network-manager, so that it ignores the card and not mess with it ever. How to make network-manager ignore your wireless card \u2013 Get you wireless card\u2019s MAC address\/hardware address ifconfig wlan0 | grep -i hwaddr It will show an output like this: wlan0 Link encap:Ethernet HWaddr 7d:e6:d2:30:9f:f2 \u2013 Open the network-manager configuration file: NetworkManager.conf nano \/etc\/NetworkManager\/NetworkManager.conf Add the following code and replace the MAC address with your selected device\u2019s MAC [main] plugins=ifupdown,keyfile [ifupdown] managed=false [keyfile] unmanaged-devices=mac:7d:e6:d2:30:9f:f2 Hit CTRL + O to save and CTRL + X to exit. \u2013 Restart network-manager: service network-manager restart This must fix the Could not configure driver mode error. Credits: https:\/\/members.rootsh3ll.com\/t\/nl80211-could-not-configure-driver-mode-hostapd-error\/197","tags":"","url":"Wireless_Communication\/WiFi_SoftAP.html"},{"title":"Bluetooth","text":"Bluetooth can be configured using the Bluetooth Manager application in the Preferences menu of the UDOObuntu Desktop. In Adapter \/ Preferences you can set the device name, and configure visiblity settings. In the main window use the Search button to discover nearby devices. Then click the devices found to connect to them. Using the command line You can use the bluetooth also from the command line. Just use the hci* and bluez* utilities which come prebundled with UDOObuntu. udooer@udooneo:~$ hcitool dev Devices: hci0 5C:31:3E:D5:7B:36 udooer@udooneo:~$","tags":"","url":"Wireless_Communication\/Bluetooth.html"},{"title":"Bluetooth NAP","text":"A Bluetooth NAP is similar to a Wi-Fi access point. It can be used to create a link between several bluetooth devices, allowing standard TCP\/IP communication. In this guide, we will make a board act like a server, other boards in the same bluetooth network (clients) will connect to the server board. Setup the server board We need to create a bridge network interface for the bluetooth connection. First, install bridge-utils: sudo apt-get install bridge-utils Create the bridge interface by adding the following lines to \/etc\/network\/interfaces: auto br0 iface br0 inet static address 192.168.66.1 netmask 255.255.255.0 bridge_ports none bridge_fd 5 bridge_stp no Configure the DHCP server so it will be able to distribuite IP addresses to client boards. Add the following lines to \/etc\/dhcp\/dhcpd.conf: subnet 192.168.66.0 netmask 255.255.255.0 { option routers 192.168.66.1; option subnet-mask 255.255.255.0; range 192.168.66.10 192.168.66.20; } Then replace the content of \/etc\/bluetooth\/network.conf with: [General] [PANU Role] Script=dhclient [GN Role] Script=dhclient [NAP Role] Interface=br0 Restart the bluetooth and networking services (or reboot the whole board): sudo \/etc\/init.d\/bluetooth restart sudo \/etc\/init.d\/networking restart Set the bluetooth as discoverable, so the client boards can find the server: bluez-test-adapter discoverable on Get the MAC address of the server bluetooth chip using: hcitool dev |grep hci0 |awk '{print $2}' You will need the server MAC address later ($MASTER_MAC). Finally, we need to advertise that NAP services are being provided by our board: wget https:\/\/gist.githubusercontent.com\/fmntf\/10c24edb2fa741d682edad969076e792\/raw\/141e5ba03b78a406bec3c3bbababc482824f6a51\/bt-nap.py chmod +x bt-nap.py .\/bt-nap.py br0 &amp; Pair the clients You need to pair and trust the client boards to the server. The easiest way to do this is using the blueman GUI. If you prefer, you can use the command line, too. On each client board, pair and trust the server board (identified by $MASTER_MAC): bluez-simple-agent hci0 $MASTER_MAC bluez-test-device trusted $MASTER_MAC yes Then connect to the NAP network using: bluez-test-network $MASTER_MAC nap dhclient bnep0 References IP over Bluetooth with Linux IP Over Bluetooth to a Raspberry Pi","tags":"","url":"Wireless_Communication\/Bluetooth_NAP.html"},{"title":"Understanding Linux Software Management And Installing","text":"Overview Visit our Tutorials section to learn more about: [Understanding Linux: Software Management And Installing]https:\/\/www.udoo.org\/tutorial\/understanding-linux-software-management-installing\/). UDOO\u2019s Ubuntu, a linux based operating system, handles software management in a way you may not be used to. It is however, very convenient at the end of the day. Ubuntu features a repository system, which is a software collection stored on several servers, which you can access and install with few commands. This ensures that updating and installing software is easy, efficient and safe. To quote from Wikipedia: In software, a package management system, also called package manager, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites. Packages are distributions of software, applications and data. Packages also contain metadata, such as the software's name, description of its purpose, version number, vendor, checksum, and a list of dependencies necessary for the software to run properly. Upon installation, metadata is stored in a local package database. UDOO's Ubuntu integrated software manager is a command-line tool called apt. Using it is very straightforward. apt has it\u2019s own repository list, stored in \/etc\/apt\/sources.list You can add or remove software sources by editing this file. To see its content just type: cat \/etc\/apt\/sources.list It is however suggested to edit this only if you know what you are doing. You can be just safe with the one included in UDOO\u2019s Ubuntu. Before attempting to install a software from a repository, let\u2019s update the apt cache. This is basically a database of all available software, that includes dependencies and version informations. To update: sudo apt-get update Then, let\u2019s assume we want to install nano, a very useful and simple text-editor: sudo apt-get install nano We will be asked if we wish to continue, let\u2019s reply yes. So, type y Apt will then download, unpack and install all file needed for us. Just wait a while and it will finish. Let\u2019s assume then, we want to remove a program, for example vim (another text-editor) sudo apt-get remove vim Again, we reply yes typing y. Some other useful commands for apt, and system housekeeping, are: apt-get autoremove removes automatically packages that are no longer required apt-get clean deleted downloaded packages that are wasting disk space We can now use another package manager, with a graphical user interface, Synaptic, which is the default package manager in most Ubuntu versions. We\u2019ll use apt to install synaptic sudo apt-get install synaptic Once installed, we\u2019ll find Synaptic Package Manager in the \u201cOther\u201d applications menu. Let\u2019s open it. Type your root password, and enter. You can then, search and install every package you like, in a nice and user friendly environment. To start, we will enable more software sources than we have by default. To do this, go to \u201csettings\u201d then \u201crepositories\u201d and check all the repositories you wish to enable; typically you should be good enabling all software sources from the \u201cUbuntu Software\u201d tab. Once done, close and hit \u201creload\u201d, which is the same as \u201capt-get update\u201d. When finished, you can start searching and browsing for thousands of different softwares, to install them simply tick the checkbox, select \u201cMark for installation\u201d and hit &quot;apply&quot;. You have now at your disposal all the software you need to further expand UDOO NEO capabilities.","tags":"","url":"Cookbook_Linux\/Understanding_Linux_Software_Management_And_Installing.html"},{"title":"Linux Command Line Interface","text":"Overview Visit our Tutorials section to learn more about: [Linux Command Line Interface]https:\/\/www.udoo.org\/tutorial\/linux-command-line-interface\/). Linux Command Line Interface, (CLI from now on) could be at first glance discouraging for the average Joe, since nowadays we are only used to Graphic Interfaces. But don\u2019t let you down, using a command line shell could be, not only very useful, but also kind of funny. This Tutorial will help you move your first steps in the command shell environment. First, when a Command Line Interface could be useful for you? Remote Connection via SSH: SSH remote connection allows to interact with UDOO NEO without physical access to it. SSH is available only with command line interface. Using a minimal Linux Distribution without a graphical interface. Some Linux Distribution come without a Graphical User Interface, in order to maximize available resources. Command line interface is your only bet in this scenario Some power-users consider CLI the most convenient way to perform code execution and file-system operations. Even if you are not in this category, you may found out that CLI can be very fast when you get used to it. Showing up with your mates, the longest your CLI strings, the more rep you\u2019ll get. So, let\u2019s start this adventure with the very basic Linux commands: sudo Your first ally, allows users to run programs with the security privileges of root, or superuser.Its name is a concatenation of &quot;su&quot; (substitute user) and &quot;do&quot;, or take action . So, if you get an error message saying that \u201conly root can do that\u201d, just use the same command with preceeded by sudo. sudo In fewer words: sudo su This just enables root privileges once for all, without forcing you to type sudo everytime. It works until you close the shell you are working into. sudo su touch create an empty file touch nano open an handy text editor, to save and exit, press &quot;ctrl&quot; and &quot;x&quot;, and tell yes or no by pressing &quot;y&quot; or &quot;n&quot; nano cat cat shows the content of a file, it speeds up file inspection for smaller files. cat \/etc\/hostname ls Shows you the content of a folder ls cd opens a specific folder cd \/home cd ubuntu cd .. Brings you to a higher folder level cd \/home\/ubuntu cd .. (\/home) cd \/ brings you to root (top filesystem level) cd \/ rm deletes a file rm myfile.my rm -rf deletes a folder rm -rf \/home\/ubuntu\/myfolder rm -rf myfolder mv moves a file or a folder. Useful for renaming also mv myfile \/myfolder\/myfile mv myfile mysecondfile cp copies a file cp myfile \/home\/ubuntu\/ cp -R copies a folder cp -R myfolder \/home\/ubuntu\/myfolder mkdir creates a folder mkdir myfolder top Top is a very useful utility, it basically gives you a complete overview of the system\u2019s status. It produces an ordered list of running processes selected by user-specified criteria. Top shows how much processing power and memory are being used, as well as other information about the running processes. top df -h Shows used and available disk space, in megabytes. df -h ifconfig -a Shows networking useful data, like current ip, netmasks and other statistics. ifconfig -a chmod chmod let you set files permissions. This utility is very important for people concerned about security, but it is useful also for coders, since you can set a script as executable with it . For a more comprehensive guide on how to use chmod see here dmesg Shows the messages resulting from the most recent system boot. It is useful for troubleshooting, since you can see which modules are loaded, which binaries are started and so on. dmesg sync Thanks to this command your SD card lifespan will drastically improve, remember to launch it every time you turn UDOO NEO off, or remove the power. Completes all pending input\/output operations. It must be launched as root, or with sudo. sync reboot reboots the system reboot shutdown shuts it down shutdown now","tags":"","url":"Cookbook_Linux\/Linux_Command_Line_Interface.html"},{"title":"Set video output","text":"Set video output to HDMI Open a terminal and run this command as super user: sudo udooscreenctl set hdmi Set video output to LVDS 7-inches panel Open a terminal and run this command as super user: sudo udooscreenctl set lvds7 Set as headless device (disable video output) This is useful to disable the HDMI chip, saving power. Open a terminal and run this command as super user: sudo udooscreenctl set headless Get current output Open a terminal and run this command as super user: sudo udooscreenctl get to get current output device. Possible outputs are: hdmi lvds7 headless","tags":"","url":"Cookbook_Linux\/Set_video_output.html"},{"title":"Device Tree Editor","text":"Introduction The device tree is a data structure used for describing hardware. The device tree is compiled by the device tree compiler (dtc), which produces binary .dtb files (also known as flattened device trees, or fdt). The data structure is a tree of named nodes and properties and it can hold any kind of data. Nodes contain properties and child nodes, while properties are name\u2013value pairs. More informations are available on here and here. UDOObuntu provides out-of-the-box device tree blobs, available in \/boot\/dts\/, for all possible combinations of board type, screen type and M4 core status. For example, UDOO Neo Basic can use the following files: imx6sx-udoo-neo-basic-hdmi-m4.dtb imx6sx-udoo-neo-basic-hdmi.dtb imx6sx-udoo-neo-basic-lvds7-m4.dtb imx6sx-udoo-neo-basic-lvds7.dtb imx6sx-udoo-neo-basic-lvds15-m4.dtb imx6sx-udoo-neo-basic-lvds15.dtb imx6sx-udoo-neo-basic-m4.dtb imx6sx-udoo-neo-basic.dtb Theboot loader loads the correct dtb file, depending on the board. Custom device trees While the board can be used with the default device tree, which exports most of the external pins as GPIO, it is also possible to export more features on the external pinout. See the section Pinmuxing to discover all the exportable configurations. On UDOO NEO the external pins can be connected to the Cortex-A9 core (the one that runs the Operative System) or to the Cortex-M4 core (the one that implements the Arduino microcontroller). UDOO Neo provides a graphical tool to change this configuration called Device Tree editor. Open if from the START menu -&gt; Preferences -&gt; Device Tree editor. To remove the feature you need to right-click on a dark orange pin in the right panel. After the functions are selected you can save by clicking on the top Save button, and then reboot the board. I2C-2: SNAP-IN Bricks connector By default the snap-in connector is assigned to the A9 and it\u2019s possible to control it by Linux driver. The I2C signal are also available on SDA - SCL pins and on pins 36\/37. If you need to use this on the M4 Arduino core, you need to remove it from the A9 core, right-clicking on the corresponding pins and removing it. After a reboot it will be possible to connect an external I2C device to the SDA SCL pins and control it from the Arduino M4 core. I2C-4 Motion Sensors bus By default the internal 9-axis motions sensors are assigned to the A9 and it is possible to control them by Linux driver. The I2C signals are also available on pins 34\/35. If you need to use them by the M4 Arduino core you need to remove it from the A9 core, right-clicking on Snap-in connector and remove it. After a reboot it will be possible to connect an external I2C device to I2C-4 pins and controll it from the Arduino M4 core. The IOMUX The i.MX processor has several pins, most of which have multiple signal options. These signal-to-pin and pin-to-signal options are selected by the input-output multiplexer called IOMUX. The IOMUX is also used to configure other pin characteristics, such as voltage level, drive strength and hysteresis. i.MX 6SoloX implements many features and can export their signals on external pad. Each pad has no fixed signal but can be changed at boot depending on the needs of the manufacturer. Every feature has one or more signals to implements its function and not all the feature can be exported at the same time on chip pads. Some of these pads are connected to external pins available to the user for connecting extra hardware or connections.","tags":"","url":"Cookbook_Linux\/Device_Tree_Editor.html"},{"title":"Change Web Control Panel port","text":"If you want to install a webserver, in order to avoid port conflicts, you need to change the port used by the Web Control Panel. Using the Web Control Panel You can change the port using the GUI provided by the Web Control Panel itself, in Configuration\/Advanced settings. Reboot your board to apply the settings. Using the terminal\/SSH To change the default port, run in a terminal: echo 8080 | sudo tee \/etc\/udoo-web-conf\/port If you want to disable the tool completely, run echo manual | sudo tee \/etc\/init\/udoo-web-conf.override Enable it again removing the override file: sudo rm \/etc\/init\/udoo-web-conf.override","tags":"","url":"Cookbook_Linux\/Change_Web_Control_Panel_port.html"},{"title":"Turn off M4 Arduino core","text":"Sometimes it may be convenient to disable the M4 core. Doing this, all the devices normally used by M4 can be used under Linux from the A9 core. Possible use cases for disabling the M4 core are: you want to use of A0-A5 analog inputs from Linux; Arduino is not needed. Using the Web Control Panel You can disable the M4 core using the GUI provided by the Web Control Panel, in Configuration\/Advanced settings. Using the terminal\/SSH Disable the M4 Arduino core sudo udoom4ctl disable Enable the M4 Arduino core sudo udoom4ctl enable Get the M4 Arduino core status sudo udoom4ctl status After the status has changed, you need to reboot the board to initialize the setting that you configured.","tags":"","url":"Cookbook_Linux\/Turn_off_M4_Arduino_core.html"},{"title":"Overview","text":"All the UDOO Neo board versions are equipped with a NXP\/Freescale iMX 6SoloX processor, which embeds on single chip an ARM Cortex A9 and an ARM Cortex M4 microcontroller. They can use and share lot of hardware implemented features provided by the architecture as: GPIOs analog inputs PWMs UARTs I2C SPI For comparison, Arduino Due uses an Atmel SAM3X M3 chip, the iMX 6soloX is the next family of microcontrollers. This means more performance, an higher clock frequency but also a high compatibility level. Having a single chip with two cores means lower power consumption, lower costs and high speed communication. In fact there isn't a shared serial port or a bus between the two cores, but an high speed shared memory. This guarantees better performance, stability and robustness. High Performances are provided by the real time operating system developed by Freescale, MQX. The high level Arduino headers are &quot;linked&quot; with low level MQX calls. These two cores are connected to all interfaces and peripherals through an high speed AXI bus. It\u2019s up to the programmer to define witch features are assigned to each processors. All the hardware features can be accessed and connected via processors pad with an editable muxing. So the functions are not fixed but can accessed on different pads. Some of these pads are connected to external pins to allow the users to connect their stuff. Vision Developing a project with UDOO Neo is like connecting an Arduino with an external PC as in UDOO Dual\/Quad. However, now all the computational power is on the same chip. M4 boot process Every time the processor is resetted, the M4 firmware (Arduino sketch) would be lost, so it needs to be reloaded by the UDOObuntu filesystem from the SD card. In this way the user can find its sketch on the board running at every boot. Moreover, during the boot the M4 requires the resources described in a configuration file. This configuration must agree with the A9 kernel configuration to avoid conflicts. We provide a default &quot;safe&quot; configuration. Last Arduino Sketch When the system boot, it checks if a sketch compiled with the Arduino IDE is saved in the default location, which is \/var\/opt\/m4\/m4last.fw. You can modify this behaviour uncommenting and modifying the m4last variable in \/boot\/uEnv.txt.","tags":"","url":"Arduino_M4_Processor\/Overview.html"},{"title":"Pinout","text":"UDOO Neo replicates the same external pinout of Arduino UNO, extended with two parallel pin rows. Internal pins are mechanically compatible with all the Arduino shields with Arduino UNO design. All the hardware features can be accessed and connected via processors pad with an editable muxing. So the functions are not fixed but can by accessed on different pads. Some of these pads are connected to the external pins, allowing the users to connect their own stuff. The external pinout is organized as follows, all pins are conceptually divided in two groups: Cortex A9 Cortex M4 (Arduino like) External pins (in orange) are by default assigned to A9 in GPIO mode. So these pins can be controlled directly from the sysfs file system in Linux and Android. Internal pins (in blue) are assigned and controlled by Cortex M4. All the compatible Arduino shields can be plugged directly on the UDOO Neo board. Pins functions can be dynamically shared at boot time between the A9 and M4 cores. By default we provide split configuration. Pinout diagram Arduino peripherals UDOO Neo replicates also the same pin functions of Arduino UNO: PWMs (8 instead of 6), SPI, I2C and UARTs. Pin logic Freescale iMX 6soloX is 3.3 Volts compliant. Analog reference voltage is GROUND and AREF is set to 3.3 Volts. The M4 architecture has more ADC and PWM resolution (compared to Arduino UNO) with more configuration mode.","tags":"","url":"Arduino_M4_Processor\/Pinout.html"},{"title":"Communication","text":"Internal cores communication To communicate between the two SoloX cores we implemented the dedicated Serial object. It is a virtualized serial that uses the shared memory to exchange datas on chip. Heads up! When you have a sketch that sends data to the serial device (\/dev\/ttyMCC) it has to be read by the A9 part otherwise it will slow down the execution: it will time out every Serial.println(). Serial.begin(115200); Serial.print('Hello'); Serial.print(&quot; &quot;); Serial.println(&quot;A9 core!&quot;); It' possible to access this serial by A9 side on device: \/dev\/ttyMCC External pinout communication The iMX 6SoloX can communicate with external peripherals in different modes. The Serial0 object allows to read and write data on pins 0 and 1 of external pinout. Serial0.begin(115200); Serial0.print('hello'); Serial0.print(&quot; &quot;); Serial0.println(&quot;world&quot;); Heads up! This serial is not connected with the A9 core (Linux\/Android). It allows only to communicate with an external UART device! Example Access the Arduino capabilities of the board in one of the following ways: via an HDMI\/LVDS screen or VNC viewer, using Arduino IDE access the UDOO Neo desktop; click on Start -&gt; Programming -&gt; Arduino IDE. use the web control panel connect to the board (eg. 192.168.7.2 if you are using the USB port); click on Arduino Editor on the left use the Arduino IDE installed on your computer Then, copy and paste the following sketch in the IDE: void setup(){ Serial.begin(115200); Serial0.begin(115200); pinMode(13, OUTPUT); } void loop(){ Serial.print(&quot;Hello&quot;); Serial.print(&quot; &quot;); Serial.println(&quot;A9!&quot;); digitalWrite(13, HIGH); delay(1000); Serial0.print(&quot;Hello&quot;); Serial0.print(&quot; &quot;); Serial0.println(&quot;world!&quot;); digitalWrite(13, LOW); delay(1000); } Click the Upload button and wait untile the message Done uploading appears on the status bar. Now, connect to the serial ports, to get the strings. Read the internal serial port Open a terminal in UDOO Neo (using the Teminal application on the Desktop, or a SSH connection) minicom -D \/dev\/ttyMCC You will see Hello A9! Read the external serial port Connect a Serial Adapter to the 0 and 1 Arduino pins and to your computer. Then open the serial port, for example using minicom: minicom -D \/dev\/ttyUSB0 You will read Hello world!","tags":"","url":"Arduino_M4_Processor\/Communication.html"},{"title":"Programming Arduino M4 from Internal Processor(Cortex-A9)","text":"Arduino IDE Heads up! The compatible Arduino IDE to program the Arduino side of UDOO NEO from the internal Cortex A9 processor is Arduino IDE 1.6.5 r3. If you need to use the latest Arduino IDE go to &quot;Arduino M4 Processor: Programming Arduino from External PC&quot;. To develop sketches for M4 cores we provide the same way to program Arduino Uno. You can use the internal Arduino IDE or connect the board and use an IDE running on external PC. Internal Arduino IDE After you connected the board and you boot the desktop environment: Start -&gt; Programming -&gt; Arduino IDE File -&gt; Examples -&gt; Basics -&gt; Blink Click on &quot;Upload&quot; button. Wait &quot;Compiling sketch...&quot; until &quot;Upload is complete&quot;. Now the sketch will be run on M4 side. Precompiled binary It's possible to upload a precompiled binary firmware on the M4 using this command: udooneo-m4uploader.sh &lt;BINARY_PATH&gt;","tags":"","url":"Arduino_M4_Processor\/Programming_Arduino_M4_from_Internal_Processor(Cortex_A9).html"},{"title":"Programming Arduino M4 from External PC","text":"External Arduino IDE Heads up!A microSD with a with UDOOBuntu2 have to be up and running to program the Arduino\u2122 M4 from an external PC. Expecially the USB direct Connection(USB OTG Gadget) and the UDOO FOTA server are the software needed. Heads up!For external programming the serial monitor doesn\u2019t work yet. Connect UDOO NEO To use the External Arduino IDE follow the instructions below: Connect UDOO NEO via Micro USB Cable to your PC In order to use UDOO NEO'S USB Connection on Mac and Windows, you must install few drivers first as described in the USB Direct Connection. Install UDOO FOTA Heads up!NOTE: If you use UDOOBuntu2 BETA 5 or previous versions you need to install the UDOO FOTA (Firmware over the Air) Server Package while if you use UDOOBuntu2 BETA 6 or later versions skip this step. To Install the UDOO FOTA you need to connect the board to internet using it either as a Computer or a Headless Device: Use as a Headless Device Use as a Lightweight Desktop PC Once you board is connected to internet open a terminal and type: sudo apt-get update sudo apt-get install udoofota-server Install and configure the Arduino IDE From your computer go to the Arduino website and downlaod the last Arduino IDE version (currently 1.6.9): Arduino IDE 1.6.9 Select the OS you have in your computer and download the IDE then install it Open the IDE, go to File -&gt; Preferences and add this link to Additional Boards Manager URLs and then click OK: https:\/\/udooboard.github.io\/arduino-board-package\/package_udoo_index.json Go to Tools -&gt; Boards and open the Board Manager. Wait few seconds 'till the end of the &quot;index download&quot; then look for UDOO NEO (iMX6 SoloX) by UDOO Team and install it. Now in Tools -&gt; Boards you should see the UDOO NEO (Cortex M4), if so Click on it. Leave the Tools -&gt; Ports unselected. Done, now you're ready to use your UDOO NEO with the Arduino IDE installed on your Computer as you usually do with a standard Arduino. Press the button Upload to load a sketch. Heads up! In order to get it working on Linux 64bit you need compatibility packages: $ sudo apt-get -y install lib32z1 lib32ncurses5 lib32bz2-1.0 Heads up! If you don't manage to install\/update the Board Manager try to delete the Arduino IDE preferences folder. Windows OS X Linux If you are using the Windows App installed from the store this is the path: C:\\Users\\&lt;user_name&gt;\\Documents\\ArduinoData\\ If you are using the Desktop App installed withe the Windows installer this is the path: C:\\Users\\&lt;user_name&gt;\\AppData\\Local\\Arduino15\\ \/Users\/&lt;user_name&gt;\/Library\/Arduino15\/ \/home\/&lt;user_name&gt;\/.arduino15\/ Remote Serial Monitor Now you can access the serial device ttyMCC from outside installing udoofota-serial package on your UDOO NEO sudo apt update sudo apt install udoofota-serial In order to reach the internal serial between M4 and A9 from outside, you must connect to UDOO Neo TCP\/IP serial socket (port 5151) and bind it to a virtual serial port. Depending on your OS, the procedure and the application to use may vary. Windows OS X Linux Download VirtualCommPort and install it. Then add COM99 and set host=&lt;udooneo_ip&gt;. You should be able to access the serial port through Arduino IDE Serial Monitor or a custom application. Install socat from the official website or like described in here. Then open a terminal and run: socat pty,link=path\/to\/newtty,raw,echo=0 tcp:&lt;udooneo_ip&gt;:5151 e.g: socat pty,link=$HOME\/mytty,raw,echo=0 tcp:192.168.7.2:5151 Download and install socat through your favorite package manager (e.g: apt install socat) and then open a terminal and run: socat pty,link=path\/to\/newtty,raw,echo=0 tcp:&lt;udooneo_ip&gt;:5151 e.g: socat pty,link=$HOME\/mytty,raw,echo=0 tcp:192.168.7.2:5151 Upload a sketch over Network You could also upload sketch Over Network from an external PC using the functionalities of the UDOO FOTA (Firmware over the Air) Server Package installed on the UDOObuntu 2 distro. You just need to know the IP Address of UDOO NEO and be in its same network. The Arduino Board Manager of UDOO NEO installs the udooclient in you external PC, this little tool interacts with the FOTA server running on the UDOO NEO. You need to modify a file in your Arduino package that is named platform.txt. For example, in Arduino IDE 1.6.9 the file is located here: Windows OS X Linux If you are using the Windows App installed from the store this is the path: C:\\Users\\&lt;user_name&gt;\\Documents\\ArduinoData\\packages\\UDOO\\hardware\\solox\\&lt;version_number&gt;\\platform.txt If you are using the Desktop App installed withe the Windows installer this is the path: C:\\Users\\&lt;user_name&gt;\\AppData\\Local\\Arduino15\\packages\\UDOO\\hardware\\solox\\&lt;version_number&gt;\\platform.txt \/Users\/&lt;user_name&gt;\/Library\/Arduino15\/packages\/UDOO\/hardware\/solox\/&lt;version_number&gt;\/platform.txt \/home\/&lt;user_name&gt;\/.arduino15\/packages\/UDOO\/hardware\/solox\/&lt;version_number&gt;\/platform.txt &lt;user_name&gt; is your User Name. &lt;version_number&gt; is the board manager package number version, can change according to changes in our repositories. At the end of platform.txt you'll find this row: tools.udooclient.upload.pattern=&quot;{path}\/{cmd}&quot; &quot;192.168.7.2:5152&quot; &quot;{build.path}\/{build.project_name}.bin&quot; 192.168.7.2 is the default Ip Address of the UDOO NEO when it is connected with the USB Direct Connection. To upload the sketch wirelessly you need to substitute the IP address in the string. Substitute 192.168.7.2:5152 with [UDOO NEO's network IP address]:5152 Save the file, now you can upload a sketch without any cable clicking the Upload button of the Arduino IDE. If you want you can also directly use the UDOO client to upload the binary without using the Arduino IDE.","tags":"","url":"Arduino_M4_Processor\/Programming_Arduino_M4_from_External_PC.html"},{"title":"Debugging","text":"Old school debugging It is possible to use following old-school debugging techniques. Serial port Use the internal or the external serial port to dump on Linux debug messages. Pin 13 LED This is a very dirty way to debug, but useful for simple sketches since it takes no time to setup. Just control the digital pin 13 to get information on code running on M4 sketch.","tags":"","url":"Arduino_M4_Processor\/Debugging.html"},{"title":"Arduino differences","text":"The UDOO Neo architecture is quite different from a standard Arduino microcontroller. In order to make it closer to the Arduino UNO usage we decided to implement some modifications to the libraries. These are the main difference. Logic levels Arduino UNO logic works on 5V. UDOO Neo instead works at 3.3V. As consequence, the analog reference voltage is GROUND and AREF is set to 3.3V. Serial ports In Arduino UNO the Serial object implements an UART serial port available both on the pins 0 and 1 and on the USB port (via an internal USB-to-serial converter). In this way, the same signals are available in two places. In UDOO Neo there are two different serial ports: Serial0 can read and write data on pins 0 and 1 of the external pinout. Serial is the internal serial port &quot;connected&quot; to the A9 core, accessible via \/dev\/ttyMCC. Heads up! When you have a sketch that sends data to the internal serial device (Serial) it has to be read by the A9 part otherwise it will slow down the execution: it will time out every Serial.println(). MCC MCC (Multi-Core Communication) is a protocol that emulate a serial port between the two cores. The driver uses a shared memory in DDR that it's used for mutual communication. It's implementation has some limitation: When launching a sketch that uses &quot;Serial.print()&quot; it's important to keep open the \/dev\/ttyMCC device, otherwise the M4 side will timeout at each call, slowing the sketch. Don't use &quot;Serial.write()&quot;, just print and println methods. PWM There is a little difference for PWM pins declaration. If you use a PWM pins you don't need to declare with pinMode(XX, OUTPUT). ADC (analog inputs) Arduino UNO analogic inputs have a resolution of 10 bit, so analogRead() returns values between 0-1023. UDOO Neo has 12-bit ADC capabilities. analogRead() will return values between 0 and 4095. Arduino sketch storage On Arduino boards, the sketch is saved in a flash memory. On UDOO Neo, the sketch is persisted on the SD card. When the board is powered on, the sketch is loaded from the \/var\/opt\/m4\/m4last.fw file and executed on the M4 core. Interrupts UDOO NEO has interrupt capability on all digital pins, like Arduino Due. For now, UDOO NEO does NOT manage: Interrupts() \/ NoInterrupts(): functions for disabling\/reenabling interrupts at the same time. Alternatively you can use attachInterrupt()\/detachInterrupt() on all the pins one by one. Strings Refer the page Arduino String Issue for further information about Strings issues. I2C\/Wire UDOO Neo M4 Processor has 2 I2C buses wired to the pinout headers and consequentially have 2 Wire objects: Wire: for Brick Connector and SCL\/SDA Pins [I2C-2] Wire1: for Motion Sensors (Accelerometer,Magnetometer,Gyroscope) [I2C-4] Be careful and double check when calling Wire.begin() or Wire1.begin() in sketches or libraries. Also check out to have I2C-2 disabled on A9 if you use Wire, and I2C-4 disabled on A9 if you use Wire1.","tags":"","url":"Arduino_M4_Processor\/Arduino_differences.html"},{"title":"Porting Libraries","text":"Some libraries don't work out-of-the-box on UDOO Neo. This is due to different architectures and the consequent use of forbidden calls. Hardware setup in constructor On UDOO Neo, hardware setup and declaration outside setup() and loop() are forbidden. So things like: TM1637Display::TM1637Display(uint8_t pinClk, uint8_t pinDIO) { \/\/ Copy the pin numbers m_pinClk = pinClk; m_pinDIO = pinDIO; \/\/ Set colon off by default? Or change the constructor? m_colon = false; \/\/ Set the pin direction and default value. \/\/ Both pins are set as inputs, allowing the pull-up resistors to pull them up pinMode(m_pinClk, INPUT); pinMode(m_pinDIO,INPUT); digitalWrite(m_pinClk, LOW); digitalWrite(m_pinDIO, LOW); } aren't correct. This issue can be fixed by moving the digitalWrite and the pinMode statements into a begin() method that it'll be called from the setup() function. PROGMEM structures Typically Arduino boards don't have lots of RAM, so some sketch\/library use PROGMEM structs to store data in flash memory and pgm_read_word functions to retrieve them. const PROGMEM uint16_t DACLookup_FullSine_5Bit[32] = { 2048, 2447, 2831, 3185, 3495, 3750, 3939, 4056, 4095, 4056, 3939, 3750, 3495, 3185, 2831, 2447, 2048, 1648, 1264, 910, 600, 345, 156, 39, 0, 39, 156, 345, 600, 910, 1264, 1648 }; UDOO Neo M4 processor don't have flash memory, but it can access lots of DDR RAM, so just get rid of those statements.","tags":"","url":"Arduino_M4_Processor\/Porting_Libraries.html"},{"title":"Controlling 9-axis motion sensors","text":"Before this section, you may want to take a look at Introduction to Pinmuxing. I2C-4 Motion Sensor Connector By default the internal 9-axis motions sensors are assigned to A9 and it\u2019s possible to control them by Linux driver. The I2C signals are also available on pins 32\/33 and 34\/35. If you need to use them by the M4 Arduino core you need to remove them from the A9 core, right-clicking on the Snap-in connector on the right panel and removing it. After reboot it will be possible to connect to I2C-4 pins an external I2C device and controll it from Arduino M4 core. Load the example Update the system by typing sudo apt-get update Load the example: #include &lt;Wire.h&gt; #include &lt;FXOS8700CQ.h&gt; #include &lt;FXAS21002C.h&gt; FXAS21002C gyroSensor = FXAS21002C(0x20); FXOS8700CQ accMagSensor = FXOS8700CQ(0x1E); bool stopLoop = false; void setup() { Serial.begin(9600); Wire1.begin(); \/\/ Initialize the FXOS8700CQ accMagSensor.init(); \/\/ Initialize the FXAS21002C gyroSensor.init(); } void loop() { \/\/ Query the sensor if (!stopLoop) { accMagSensor.readAccelData(); accMagSensor.readMagData(); gyroSensor.getGres(); gyroSensor.readGyroData(); \/\/ Query the sensor \/\/ Print out the data \/\/ Accelerometer Serial.print(&quot;Accel &quot;); Serial.print(&quot; &quot;); Serial.print((int)accMagSensor.accelData.x); Serial.print(&quot; &quot;); Serial.print((int)accMagSensor.accelData.y); Serial.print(&quot; &quot;); Serial.println((int)accMagSensor.accelData.z); \/\/ Magnetometer Serial.print(&quot; Mag &quot;); Serial.print(&quot; &quot;); Serial.print((int)accMagSensor.magData.x); Serial.print(&quot; &quot;); Serial.print((int)accMagSensor.magData.y); Serial.print(&quot; &quot;); Serial.println((int)accMagSensor.magData.z); \/\/ Gyroscope Serial.print(&quot; Gyro &quot;); Serial.print(&quot; &quot;); Serial.print((int)gyroSensor.gyroData.x); Serial.print(&quot; &quot;); Serial.print((int)gyroSensor.gyroData.y); Serial.print(&quot; &quot;); Serial.println((int)gyroSensor.gyroData.z); delay(100); } }","tags":"","url":"Arduino_M4_Processor\/Controlling_9_axis_motion_sensors.html"},{"title":"Use more digital pins on M4","text":"As described in this section, all the processor features (gpio, adc, spi, i2c\u2026) can theoretically assigned to both cores. For example is possible to assign to M4 core, more than 14 gpio as by default. To do this we need to modify the muxing configuration of both cores. First of all we need modify the device tree configuration to recompile the dtb, to avoid to assign these pins to A9. Than we can assign this pins to the M4 and connect it to Arduino Libraries. A9 operations To recompile the kernel please follow this guide to set up the kernel compiling enviroment. After that i\u2019ll explain how the gpios configuration dts is organized. In the file imx6sx-udoo-neo-external.dtsi are listed all the external pins that can be used as gpio by the linux kernel. As you see some of the macros are commented. &amp;iomuxc { imx6x-udoo-neo { \/\/ External Pinout GPIOs external_hog: hoggrp-2 { fsl,pins = &lt; MX6SX_PAD_NAND_DATA06__GPIO4_IO_10 0x80000000 \/\/ {{external-gpio-16}} MX6SX_PAD_NAND_DATA07__GPIO4_IO_11 0x80000000 \/\/ {{external-gpio-17}} MX6SX_PAD_SD4_DATA6__GPIO6_IO_20 0x80000000 \/\/ {{external-gpio-18}} MX6SX_PAD_SD4_DATA7__GPIO6_IO_21 0x80000000 \/\/ {{external-gpio-19}} MX6SX_PAD_SD4_CLK__GPIO6_IO_12 0x80000000 \/\/ {{external-gpio-20}} MX6SX_PAD_SD4_CMD__GPIO6_IO_13 0x80000000 \/\/ {{external-gpio-21}} MX6SX_PAD_SD4_RESET_B__GPIO6_IO_22 0x80000000 \/\/ {{external-gpio-22}} MX6SX_PAD_CSI_PIXCLK__GPIO1_IO_24 0x80000000 \/\/ {{external-gpio-23}} MX6SX_PAD_CSI_VSYNC__GPIO1_IO_25 0x80000000 \/\/ {{external-gpio-24}} MX6SX_PAD_CSI_HSYNC__GPIO1_IO_22 0x80000000 \/\/ {{external-gpio-25}} MX6SX_PAD_CSI_DATA00__GPIO1_IO_14 0x80000000 \/\/ {{external-gpio-26}} MX6SX_PAD_CSI_DATA01__GPIO1_IO_15 0x80000000 \/\/ {{external-gpio-27}} MX6SX_PAD_CSI_DATA02__GPIO1_IO_16 0x80000000 \/\/ {{external-gpio-28}} MX6SX_PAD_CSI_DATA03__GPIO1_IO_17 0x80000000 \/\/ {{external-gpio-29}} MX6SX_PAD_CSI_DATA04__GPIO1_IO_18 0x80000000 \/\/ {{external-gpio-30}} MX6SX_PAD_CSI_DATA05__GPIO1_IO_19 0x80000000 \/\/ {{external-gpio-31}} MX6SX_PAD_CSI_DATA06__GPIO1_IO_20 0x80000000 \/\/ {{external-gpio-32}} MX6SX_PAD_CSI_DATA07__GPIO1_IO_21 0x80000000 \/\/ {{external-gpio-33}} \/\/MX6SX_PAD_USB_H_STROBE__GPIO7_IO_11 0x80000000 \/\/ {{external-gpio-34}} \/\/MX6SX_PAD_USB_H_DATA__GPIO7_IO_10 0x80000000 \/\/ {{external-gpio-35}} MX6SX_PAD_SD4_DATA3__GPIO6_IO_17 0x80000000 \/\/ {{external-gpio-36}} MX6SX_PAD_SD4_DATA2__GPIO6_IO_16 0x80000000 \/\/ {{external-gpio-37}} MX6SX_PAD_SD4_DATA1__GPIO6_IO_15 0x80000000 \/\/ {{external-gpio-38}} MX6SX_PAD_SD4_DATA0__GPIO6_IO_14 0x80000000 \/\/ {{external-gpio-39}} MX6SX_PAD_QSPI1A_SS1_B__GPIO4_IO_23 0x80000000 \/\/ {{external-gpio-40}} MX6SX_PAD_QSPI1B_DQS__GPIO4_IO_28 0x80000000 \/\/ {{external-gpio-41}} MX6SX_PAD_QSPI1B_SS1_B__GPIO4_IO_31 0x80000000 \/\/ {{external-gpio-42}} MX6SX_PAD_QSPI1A_DQS__GPIO4_IO_20 0x80000000 \/\/ {{external-gpio-43}} MX6SX_PAD_GPIO1_IO07__GPIO1_IO_7 0x80000000 \/\/ {{external-gpio-44}} MX6SX_PAD_GPIO1_IO06__GPIO1_IO_6 0x80000000 \/\/ {{external-gpio-45}} \/\/MX6SX_PAD_GPIO1_IO05__GPIO1_IO_5 0x80000000 \/\/ {{external-gpio-46}} \/\/MX6SX_PAD_GPIO1_IO04__GPIO1_IO_4 0x80000000 \/\/ {{external-gpio-47}} &gt;; }; This is just because these pins are used as: I2C-4 connected also to internal 9axis motion sensor \/\/MX6SX_PAD_USB_H_STROBE__GPIO7_IO_11 0x80000000 \/\/ {{external-gpio-34}} \/\/MX6SX_PAD_USB_H_DATA__GPIO7_IO_10 0x80000000 \/\/ {{external-gpio-35}} UART-1 debug serial \/\/MX6SX_PAD_GPIO1_IO05__GPIO1_IO_5 0x80000000 \/\/ {{external-gpio-46}} \/\/MX6SX_PAD_GPIO1_IO04__GPIO1_IO_4 0x80000000 \/\/ {{external-gpio-47}} So we need to comment all the lines that we need to use by the M4 core. Eg. If we want to use all the gpio pins closer to UART1 we can comment all the block \/\/ MX6SX_PAD_USB_H_STROBE__GPIO7_IO_11 0x80000000 \/\/ {{external-gpio-34}} \/\/ MX6SX_PAD_USB_H_DATA__GPIO7_IO_10 0x80000000 \/\/ {{external-gpio-35}} \/\/ MX6SX_PAD_SD4_DATA3__GPIO6_IO_17 0x80000000 \/\/ {{external-gpio-36}} \/\/ MX6SX_PAD_SD4_DATA2__GPIO6_IO_16 0x80000000 \/\/ {{external-gpio-37}} \/\/ MX6SX_PAD_SD4_DATA1__GPIO6_IO_15 0x80000000 \/\/ {{external-gpio-38}} \/\/ MX6SX_PAD_SD4_DATA0__GPIO6_IO_14 0x80000000 \/\/ {{external-gpio-39}} Ok? Otherwise, if we are sure that we don\u2019t need any gpio pin from A9 core we can remove the whole block from another file, without touching imx6sx-udoo-neo-external.dtsi. Open imx6sx-udoo-neo.dtsi and remove the &amp;external_hog reference. &amp;iomuxc { pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_hog &amp;external_hog&gt;; imx6x-udoo-neo { [ ... ] becomes &amp;iomuxc { pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_hog&gt;; imx6x-udoo-neo { [ ... ] Save and close the file an than recompile al the dts files. Then copy all of them into the \/boot\/dts folder in your UDOOBuntu microSD. Arduino M4 side To assign all the gpio (digitalOutputs) to M4 cores you need to open edit two files contained on the UDOObuntu filesystem, also directly from UDOO NEO. These are: \/usr\/share\/arduino\/hardware\/UDOO\/solox\/variants\/udooneo\/wiring_digital.h \/usr\/share\/arduino\/hardware\/UDOO\/solox\/variants\/udooneo\/wiring_digital.c wiring_digital.h In this file we only need to change a define containing the maximum number of gpio. #define ARD_NMAX_DIO 14 to be changed depending the number of added gpio. If you add 2 gpio it must be 16. #define ARD_NMAX_DIO 16 wiring_digital.c Then upgrathe this table with correct pin mux end pin control macros. \/\/ Default Arduino pins #define ARD_DIO0 (LWGPIO_PORT4 | LWGPIO_PIN10) #define ARD_DIO0_MUX_GPIO (LWGPIO_MUX_PORT4_PIN10_GPIO) #define ARD_DIO1 (LWGPIO_PORT4 | LWGPIO_PIN11) #define ARD_DIO1_MUX_GPIO (LWGPIO_MUX_PORT4_PIN11_GPIO) #define ARD_DIO2 (LWGPIO_PORT4 | LWGPIO_PIN8) #define ARD_DIO2_MUX_GPIO (LWGPIO_MUX_PORT4_PIN8_GPIO) #define ARD_DIO3 (LWGPIO_PORT5 | LWGPIO_PIN15) #define ARD_DIO3_MUX_GPIO (LWGPIO_MUX_PORT5_PIN15_GPIO) #define ARD_DIO4 (LWGPIO_PORT5 | LWGPIO_PIN14) #define ARD_DIO4_MUX_GPIO (LWGPIO_MUX_PORT5_PIN14_GPIO) #define ARD_DIO5 (LWGPIO_PORT5 | LWGPIO_PIN13) #define ARD_DIO5_MUX_GPIO (LWGPIO_MUX_PORT5_PIN13_GPIO) #define ARD_DIO6 (LWGPIO_PORT5 | LWGPIO_PIN12) #define ARD_DIO6_MUX_GPIO (LWGPIO_MUX_PORT5_PIN12_GPIO) #define ARD_DIO7 (LWGPIO_PORT5 | LWGPIO_PIN21) #define ARD_DIO7_MUX_GPIO (LWGPIO_MUX_PORT5_PIN21_GPIO) #define ARD_DIO8 (LWGPIO_PORT4 | LWGPIO_PIN9) #define ARD_DIO8_MUX_GPIO (LWGPIO_MUX_PORT4_PIN9_GPIO) #define ARD_DIO9 (LWGPIO_PORT5 | LWGPIO_PIN20) #define ARD_DIO9_MUX_GPIO (LWGPIO_MUX_PORT5_PIN20_GPIO) #define ARD_DIO10 (LWGPIO_PORT4 | LWGPIO_PIN5) #define ARD_DIO10_MUX_GPIO (LWGPIO_MUX_PORT4_PIN5_GPIO) #define ARD_DIO11 (LWGPIO_PORT4 | LWGPIO_PIN7) #define ARD_DIO11_MUX_GPIO (LWGPIO_MUX_PORT4_PIN7_GPIO) #define ARD_DIO12 (LWGPIO_PORT4 | LWGPIO_PIN4) #define ARD_DIO12_MUX_GPIO (LWGPIO_MUX_PORT4_PIN4_GPIO) #define ARD_DIO13 (LWGPIO_PORT4 | LWGPIO_PIN6) #define ARD_DIO13_MUX_GPIO (LWGPIO_MUX_PORT4_PIN6_GPIO) \/\/ All gpios exported #define ARD_DIO14 (LWGPIO_PORT1 | LWGPIO_PIN3) #define ARD_DIO14_MUX_GPIO (LWGPIO_MUX_PORT1_PIN3_GPIO) #define ARD_DIO15 (LWGPIO_PORT1 | LWGPIO_PIN2) #define ARD_DIO15_MUX_GPIO (LWGPIO_MUX_PORT1_PIN2_GPIO) #define ARD_DIO16 (LWGPIO_PORT4 | LWGPIO_PIN10) #define ARD_DIO16_MUX_GPIO (LWGPIO_MUX_PORT4_PIN10_GPIO) #define ARD_DIO17 (LWGPIO_PORT4 | LWGPIO_PIN11) #define ARD_DIO17_MUX_GPIO (LWGPIO_MUX_PORT4_PIN11_GPIO) #define ARD_DIO18 (LWGPIO_PORT6 | LWGPIO_PIN20) #define ARD_DIO18_MUX_GPIO (LWGPIO_MUX_PORT6_PIN20_GPIO) #define ARD_DIO19 (LWGPIO_PORT6 | LWGPIO_PIN21) #define ARD_DIO19_MUX_GPIO (LWGPIO_MUX_PORT6_PIN21_GPIO) #define ARD_DIO20 (LWGPIO_PORT6 | LWGPIO_PIN12) #define ARD_DIO20_MUX_GPIO (LWGPIO_MUX_PORT6_PIN12_GPIO) #define ARD_DIO21 (LWGPIO_PORT6 | LWGPIO_PIN13) #define ARD_DIO21_MUX_GPIO (LWGPIO_MUX_PORT6_PIN13_GPIO) #define ARD_DIO22 (LWGPIO_PORT6 | LWGPIO_PIN22) #define ARD_DIO22_MUX_GPIO (LWGPIO_MUX_PORT6_PIN22_GPIO) #define ARD_DIO23 (LWGPIO_PORT1 | LWGPIO_PIN24) #define ARD_DIO23_MUX_GPIO (LWGPIO_MUX_PORT1_PIN24_GPIO) #define ARD_DIO24 (LWGPIO_PORT1 | LWGPIO_PIN25) #define ARD_DIO24_MUX_GPIO (LWGPIO_MUX_PORT1_PIN25_GPIO) #define ARD_DIO25 (LWGPIO_PORT1 | LWGPIO_PIN22) #define ARD_DIO25_MUX_GPIO (LWGPIO_MUX_PORT1_PIN22_GPIO) #define ARD_DIO26 (LWGPIO_PORT1 | LWGPIO_PIN14) #define ARD_DIO26_MUX_GPIO (LWGPIO_MUX_PORT1_PIN14_GPIO) #define ARD_DIO27 (LWGPIO_PORT1 | LWGPIO_PIN15) #define ARD_DIO27_MUX_GPIO (LWGPIO_MUX_PORT1_PIN15_GPIO) #define ARD_DIO28 (LWGPIO_PORT1 | LWGPIO_PIN16) #define ARD_DIO28_MUX_GPIO (LWGPIO_MUX_PORT1_PIN16_GPIO) #define ARD_DIO29 (LWGPIO_PORT1 | LWGPIO_PIN17) #define ARD_DIO29_MUX_GPIO (LWGPIO_MUX_PORT1_PIN17_GPIO) #define ARD_DIO30 (LWGPIO_PORT1 | LWGPIO_PIN18) #define ARD_DIO30_MUX_GPIO (LWGPIO_MUX_PORT1_PIN18_GPIO) #define ARD_DIO31 (LWGPIO_PORT1 | LWGPIO_PIN19) #define ARD_DIO31_MUX_GPIO (LWGPIO_MUX_PORT1_PIN19_GPIO) #define ARD_DIO32 (LWGPIO_PORT1 | LWGPIO_PIN20) #define ARD_DIO32_MUX_GPIO (LWGPIO_MUX_PORT1_PIN20_GPIO) #define ARD_DIO33 (LWGPIO_PORT1 | LWGPIO_PIN21) #define ARD_DIO33_MUX_GPIO (LWGPIO_MUX_PORT1_PIN21_GPIO) #define ARD_DIO34 (LWGPIO_PORT7 | LWGPIO_PIN11) #define ARD_DIO34_MUX_GPIO (LWGPIO_MUX_PORT7_PIN11_GPIO) #define ARD_DIO35 (LWGPIO_PORT7 | LWGPIO_PIN10) #define ARD_DIO35_MUX_GPIO (LWGPIO_MUX_PORT7_PIN10_GPIO) Than you can add these define to this const array. const DioPinMap arduinoToMqx_Pin[ARD_NMAX_DIO] = { {ARD_DIO0, ARD_DIO0_MUX_GPIO}, \/\/ 0 {ARD_DIO1, ARD_DIO1_MUX_GPIO}, \/\/ 1 {ARD_DIO2, ARD_DIO2_MUX_GPIO}, \/\/ 2 {ARD_DIO3, ARD_DIO3_MUX_GPIO}, \/\/ 3 {ARD_DIO4, ARD_DIO4_MUX_GPIO}, \/\/ 4 {ARD_DIO5, ARD_DIO5_MUX_GPIO}, \/\/ 5 {ARD_DIO6, ARD_DIO6_MUX_GPIO}, \/\/ 6 {ARD_DIO7, ARD_DIO7_MUX_GPIO}, \/\/ 7 {ARD_DIO8, ARD_DIO8_MUX_GPIO}, \/\/ 8 {ARD_DIO9, ARD_DIO9_MUX_GPIO}, \/\/ 9 {ARD_DIO10, ARD_DIO10_MUX_GPIO}, \/\/ 10 {ARD_DIO11, ARD_DIO11_MUX_GPIO}, \/\/ 11 {ARD_DIO12, ARD_DIO12_MUX_GPIO}, \/\/ 12 {ARD_DIO13, ARD_DIO13_MUX_GPIO}, \/\/ 13 \/\/ Pins assigned to A9 (i2C-2) \/\/ {ARD_DIO14, ARD_DIO14_MUX_GPIO}, \/\/ 14 SDA \/\/ {ARD_DIO15, ARD_DIO15_MUX_GPIO}, \/\/ 15 SCL *\/ {ARD_DIO16, ARD_DIO16_MUX_GPIO}, \/\/ 16 {ARD_DIO17, ARD_DIO17_MUX_GPIO}, \/\/ 17 {ARD_DIO18, ARD_DIO18_MUX_GPIO}, \/\/ 18 {ARD_DIO19, ARD_DIO19_MUX_GPIO}, \/\/ 19 {ARD_DIO20, ARD_DIO20_MUX_GPIO}, \/\/ 20 {ARD_DIO21, ARD_DIO21_MUX_GPIO}, \/\/ 21 {ARD_DIO22, ARD_DIO22_MUX_GPIO}, \/\/ 22 {ARD_DIO23, ARD_DIO23_MUX_GPIO}, \/\/ 23 {ARD_DIO24, ARD_DIO24_MUX_GPIO}, \/\/ 24 {ARD_DIO25, ARD_DIO25_MUX_GPIO}, \/\/ 25 {ARD_DIO26, ARD_DIO26_MUX_GPIO}, \/\/ 26 {ARD_DIO27, ARD_DIO27_MUX_GPIO}, \/\/ 27 {ARD_DIO28, ARD_DIO28_MUX_GPIO}, \/\/ 28 {ARD_DIO29, ARD_DIO29_MUX_GPIO}, \/\/ 29 {ARD_DIO30, ARD_DIO30_MUX_GPIO}, \/\/ 30 {ARD_DIO31, ARD_DIO31_MUX_GPIO}, \/\/ 31 {ARD_DIO32, ARD_DIO32_MUX_GPIO}, \/\/ 32 {ARD_DIO33, ARD_DIO33_MUX_GPIO}, \/\/ 33 {ARD_DIO34, ARD_DIO34_MUX_GPIO}, \/\/ 34 {ARD_DIO35, ARD_DIO35_MUX_GPIO}, \/\/ 35 }; ATTENTION: when you call Arduino methods pinMode(X, &lt;INPUT\/OUTPUT&gt; ) digitalWrite(X, &lt;LOW\/HIGH&gt; ) digitalRead(X) pin numbers ( x ) may differ from pcb. If you added only the pin 16 gpio, you can access it calling digitalRead(14). Depending the position of the list.","tags":"","url":"Arduino_M4_Processor\/Use_more_digital_pins_on_M4.html"},{"title":"Hall Sensor","text":"Description The Hall effect is the production of a voltage difference (the Hall voltage) across an electrical conductor, transverse to an electric current in the conductor and a magnetic field perpendicular to the current. It was discovered by Edwin Hall in 1879. The Hall coefficient is defined as the ratio of the induced electric field to the product of the current density and the applied magnetic field. It is a characteristic of the material from which the conductor is made, since its value depends on the type, number, and properties of the charge carriers that constitute the current. A good document explaining how this effect works is available here. Tested devices 44E-938 A Hall generator is a solid state sensor which provides an output voltage when it detects magnetic flux. As implied by its name, this device relies on the Hall effect. The Hall effect is the development of a voltage across a sheet of conductor when current is flowing and the conductor is placed in a magnetic field. 49E-416BG 49E Linear Hall-effect sensor is small, versatile linear Hall-effect device that is operated by the magnetic field from a permanent magnet or an electromagnet. The linear sourcing output voltage is set by the supply voltage and varies in proportion to the strength of the magnetic field. The integrated circuitry features low noise output, which makes it unnecessary to use external filtering. It also includes thin film resistors to provide increased temperature stability and accuracy. The linear Hall sensor has an operating temperature range of -40 \u00b0C to 85 \u00b0C appropriate for commercial, consumer and industrial environments. Examples 44e-938 49E-416BG int val = 0; \/\/ This holds the read value. void setup(){ pinMode(2, INPUT); \/\/ Read the input on pin 2 pinMode(13, OUTPUT); \/\/ I used pin 13 since it has an LED on the UNO built-in. Serial.begin(9600); \/\/ I also wanted to confirm the value I read. } void loop(){ val = digitalRead( 2 ); \/\/ Go read the pin. Serial.println(val); \/\/ just to see on the serial monitor what I read. if ( val == HIGH ) digitalWrite ( 13, LOW ); \/\/ Turn on the LED when the value is high. else digitalWrite ( 13, HIGH ); \/\/ Turn off the LED when the value is low. } After copying and uploading this code your LED should be off. Whenever a magnet approaches the sensor, it will allow the electricity to flow and the LED will turn on. If it doesn't work on the first time, try using a bigger and stronger magnet, it could make a difference. Also, the sensor is very sensitive to polarity, so try moving the magnet around it. And last, don't forget the reach isn't too big, so make sure that the magnet is close to the sensor. int sensorPin = A5; \/\/ select the input pin for the potentiometer int ledPin = 13; \/\/ select the pin for the LED int sensorValue = 0; \/\/ variable to store the value coming from the sensor void setup() { pinMode(ledPin, OUTPUT); Serial.begin(9600); } void loop() { sensorValue = analogRead(sensorPin); digitalWrite(ledPin, HIGH); delay(sensorValue); digitalWrite(ledPin, LOW); delay(sensorValue); Serial.println(sensorValue, DEC); } const int ledPin = 13; const int A0Pin = A0; #define D0Pin 8 void setup() { pinMode(ledPin,OUTPUT); pinMode(D0Pin, INPUT); } void loop() { int analogVal = analogRead(A0Pin); int digitalVal = digitalRead(D0Pin); Serial.print(analogVal); Serial.print(&quot;analog: &quot;); Serial.print(&quot; digital: &quot;); Serial.println(digitalVal); }","tags":"","url":"Cookbook_Arduino_M4\/Hall_Sensor.html"},{"title":"RGB led","text":"Description The RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors. The name of the model comes from the initials of the three additive primary colors, red, green, and blue. At first glance, RGB (Red, Green, Blue) LEDs look just like regular LEDs, however, inside the usual LED package, there are actually three LEDs, one red, one green and yes, one blue. By controlling the brightness of each of the individual LEDs you can mix pretty much any color you want. They are called SMD 5050 because the dimensions of the chips are 5.0mm x 5.0mm. RGB LEDs are Tri-color LEDs with red, green, and blue emitters, in general using a four-wire connection with one common lead (anode or cathode). These LEDs can have either common positive or common negative leads. Others however, have only two leads (positive and negative) and have a built in tiny electronic control unit. How does it work A light-emitting diode (LED) is a two-lead semiconductor light source. It is a p\u2013n junction diode, which emits light when activated. When a suitable voltage is applied to the leads, electrons are able to recombine with electron holes within the device, releasing energy in the form of photons. This effect is called electroluminescence, and the color of the light (corresponding to the energy of the photon) is determined by the energy band gap of the semiconductor. Device information 5050 LED Specifications Red Vf: 1.8 to 2.1V Green Vf: 3.0 to 3.2V Blue Vf: 3.0 to 3.2V Red color: 620-625 nm Green color: 520-525 nm Blue color: 465-470 nm Red brightness @ ~20mA: 600-800 mcd Blue brightness @ ~20mA: 800-1000 mcd Green brightness @ ~20mA: 1500-2000mcd Example const int redPin = 11; \/\/ R petal on RGB LED module connected to digital pin 11 const int greenPin = 10; \/\/ G petal on RGB LED module connected to digital pin 9 const int bluePin = 9; \/\/ B petal on RGB LED module connected to digital pin 10 void setup() { \/\/ pinMode(redPin, OUTPUT); \/\/ Unlike Arduino, no PWM pins declaration needed in UDOO NEO \/\/ pinMode(greenPin, OUTPUT); \/\/ pinMode(bluePin, OUTPUT); } void loop() \/\/ run over and over again { \/\/ Basic colors: color(255, 0, 0); \/\/ turn the RGB LED red delay(1000); \/\/ delay for 1 second color(0,255, 0); \/\/ turn the RGB LED green delay(1000); \/\/ delay for 1 second color(0, 0, 255); \/\/ turn the RGB LED blue delay(1000); \/\/ delay for 1 second \/\/ Example blended colors: color(255,0,0); \/\/ turn the RGB LED red delay(1000); \/\/ delay for 1 second color(237,109,0); \/\/ turn the RGB LED orange delay(1000); \/\/ delay for 1 second color(255,215,0); \/\/ turn the RGB LED yellow delay(1000); \/\/ delay for 1 second color(0,255,0); \/\/ turn the RGB LED green delay(1000); \/\/ delay for 1 second color(0,0,255); \/\/ turn the RGB LED blue delay(1000); \/\/ delay for 1 second color(0,46,90); \/\/ turn the RGB LED indigo delay(1000); \/\/ delay for 1 second color(128,0,128); \/\/ turn the RGB LED purple delay(1000); \/\/ delay for 1 second } void color (unsigned char red, unsigned char green, unsigned char blue) \/\/ the color generating function { analogWrite(redPin, red); analogWrite(bluePin, blue); analogWrite(greenPin, green); }","tags":"","url":"Cookbook_Arduino_M4\/RGB_led.html"},{"title":"Two color common cathode led","text":"How does it work A light-emitting diode (LED) is a two-lead semiconductor light source. It is a p\u2013n junction diode, which emits light when activated. When a suitable voltage is applied to the leads, electrons are able to recombine with electron holes within the device, releasing energy in the form of photons. This effect is called electroluminescence, and the color of the light (corresponding to the energy of the photon) is determined by the energy band gap of the semiconductor. Device information Connect the left pin ( G or Minus ) to Ground and the other two pins to a digital PWM output. Example int redPin = 11; \/\/ select the pin for the red LED int greenPin = 10; \/\/ select the pin for the greenLED int val = 0; void setup() { \/\/pinMode(redPin, OUTPUT); \/\/ Unlike Arduino, no PWM pins declaration needed in UDOO NEO \/\/pinMode(greenPin, OUTPUT); Serial.begin(9600); } void loop() { for(val=255; val&gt;0; val--) { analogWrite(redPin, val); analogWrite(greenPin, 255-val); Serial.println(val, DEC); delay(15); } for(val=0; val&lt;255; val++) { analogWrite(redPin, val); analogWrite(greenPin, 255-val); Serial.println(val, DEC); delay(15); } }","tags":"","url":"Cookbook_Arduino_M4\/Two_color_common_cathode_led.html"},{"title":"Knock sensor","text":"Description Knock sensor module and a digital 13 interface, built-in LED build a simple circuit to produce percussion flasher. Interface comes with digital LED, will knock sensor connected digital 3 interface, when percussion sensor senses measure to percussive signals, LED flashing light. The knock sensor, detects the knocks and the taps. It can work like a switch. The sensor sends data momentarily to the board. To keep the LED on, the button state change codes should be used. So the sensor will work as a switch. KY-031 (Knock Sensor) The switch primarily consists of a terminal that forms a center post and a second terminal that is a spring that surrounds the center post. When a sufficient force is transferred to the switch, the terminal consisting of the spring moves and shorts both terminals together. The connection between the terminals is momentary and will require a little thought as you implement it in your Arduino project. Positioning of the switch is also important. Generally speaking the switch should be physically located as close as possible to the area being monitored. Otherwise, the vibration being detected may be dampened by other structural components in your project. An exception to this rule may be where you find that the switch is too sensitive for your application. In this case, moving the switch further away from the area of interest may make it less sensitive. Examples const int knockPin = 3; \/\/ the number of the knock sensor pin const int ledPin = 13; \/\/ the number of the LED pin \/\/ variables will change: int buttonState = 0; \/\/ variable for reading the knock sensor status void setup() { \/\/ initialize the LED pin as an output: pinMode(ledPin, OUTPUT); \/\/ initialize the knock sensor pin as an input: pinMode(knockPin, INPUT); } void loop(){ \/\/ read the state of the knock sensor value: buttonState = digitalRead(knockPin); \/\/ check if the knock sensor is pressed. \/\/ if it is, the knock sensor is HIGH: if (buttonState == HIGH) { \/\/ turn LED on: digitalWrite(ledPin, LOW); } else { \/\/ turn LED off: digitalWrite(ledPin, HIGH); } } const int buttonPin = 3; \/\/ the pin that the pushbutton is attached to const int ledPin = 13; \/\/ the pin that the LED is attached to \/\/ Variables will change: int buttonPushCounter = 0; \/\/ counter for the number of button presses int buttonState = 0; \/\/ current state of the button int lastButtonState = 0; \/\/ previous state of the button void setup() { \/\/ initialize the button pin as a input: pinMode(buttonPin, INPUT); \/\/ initialize the LED as an output: pinMode(ledPin, OUTPUT); \/\/ initialize serial communication: Serial.begin(9600); } void loop() { \/\/ read the pushbutton input pin: buttonState = digitalRead(buttonPin); \/\/ compare the buttonState to its previous state if (buttonState != lastButtonState) { \/\/ if the state has changed, increment the counter if (buttonState == HIGH) { \/\/ if the current state is HIGH then the button \/\/ wend from off to on: buttonPushCounter++; Serial.println(&quot;on&quot;); Serial.print(&quot;number of button pushes: &quot;); Serial.println(buttonPushCounter); } else { \/\/ if the current state is LOW then the button \/\/ wend from on to off: Serial.println(&quot;off&quot;); } } \/\/ save the current state as the last state, \/\/for next time through the loop lastButtonState = buttonState; \/\/ turns on the LED every four button pushes by \/\/ checking the modulo of the button push counter. \/\/ the modulo function gives you the remainder of \/\/ the division of two numbers: if (buttonPushCounter % 4 == 0) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } }","tags":"","url":"Cookbook_Arduino_M4\/Knock_sensor.html"},{"title":"Infrared Transmit","text":"Description Infrared emitting diodes: clean, good condition; various parameters during operation must not exceed limit values (positive To the current 30 ~ 60 mA, Pulse Forward Current 0.3 ~ 1 A, reverse voltage 5 V, power dissipation 90 mW, the working temperature Range -25 ~ +80 \u2103, storage temperature range of -40 ~ +100 \u2103, soldering temperature of 260\u2103) infrared emission tube and then Closed head should be paired with, otherwise it will affect the sensitivity. Example #include &lt;IRremote.h&gt; IRsend irsend; const int ledPin = 13; void setup() { pinMode(ledPin, OUTPUT); } void loop() { digitalWrite(ledPin, HIGH); irsend.sendNEC(0xFFA25D, 32); delay(1000); digitalWrite(ledPin, LOW); delay(1000); }","tags":"","url":"Cookbook_Arduino_M4\/Infrared_Transmit.html"},{"title":"Serial Libraries","text":"UDOO NEO Serial Libraries Examples Serial Libraries Communication Samples for UDOO Board These scripts are examples meant to demonstrate how to implement a uni\/bidirectional communication between an Arduino sketch (running on Cortex-M4 Arduino\u2122 Compatible processor) and a binary application on iMX6 Linux processor. The Arduino sketch will remain the same no matter which programming language you\u2019ll use to develop the binary on iMX6. There are two example scripts for each programming language: C, Java, PHP, Python. You can find the whole repo in our Github Channel. Clone the repo in your system using this command on a terminal: git clone https:\/\/github.com\/UDOOboard\/serial_libraries_examples.git Each program is meant to be executed while the matching Arduino Sketch is running on SAM3X. Program the Arduino\u2122 embedded with the sketch named arduino_serial_example.ino before run these examples: c_serial_example.c java_serial_example.java php_serial_example.php python_serial_example.py Program the Arduino\u2122 embedded with the sketch named arduino_serial_example_bidirectional.ino before run these examples: c_serial_example_bidirectional.c java_serial_example_bidirectional.java php_serial_example_bidirectional.php python_serial_example_bidirectional.py","tags":"","url":"Serial_Libraries\/index.html"},{"title":"Java Serial Libraries","text":"JAVA Serial libraries for UDOO NEO This file describes how to compile and run the Java examples contained in this folder. 1 - Starting from UDOObuntu2 all the libraries and link should be preinstalled. Otherwise install the java serial library: sudo apt-get install librxtx-java 2 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttyMCC \/dev\/ttyS0 3 - Open a terminal and navigate to this folder: cd serial_libraries_examples\/java\/ 4 - Compile the Java file: for Java_serial_example.java: javac -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example.java for Java_serial_example_bidirectional.java: javac -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example_bidirectional.java 5 - Run the Java program: for Java_serial_example.java: java -Djava.library.path=\/usr\/lib\/jni -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example for Java_serial_example_bidirectional.java: java -Djava.library.path=\/usr\/lib\/jni -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example_bidirectional","tags":"","url":"Serial_Libraries\/Java_Serial_Libraries.html"},{"title":"C Serial Libraries","text":"C Serial Libraries for UDOO NEO This file describes how to compile and run the C examples contained in this folder. 1 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttyMCC \/dev\/ttyS0 2 - Open a terminal and navigate to this folder: cd serial_libraries_examples\/c\/ 3 - Compile the C file: for c_serial_example.c: gcc -o c_serial_example c_serial_example.c for c_serial_example_bidirectional.c: gcc -o c_serial_example_bidirectional c_serial_example_bidirectional.c 4 - Run the C program: for c_serial_example.c: .\/c_serial_example for c_serial_example_bidirectional.c: .\/c_serial_example_bidirectional","tags":"","url":"Serial_Libraries\/C_Serial_Libraries.html"},{"title":"PHP Serial Libraries","text":"PHP Serial Libraries for UDOO NEO This file describes how to run the PHP examples contained in this folder. To run these PHP examples, we will use the PHP interpreter and its embedded Web Server. The same examples can be executed over Apache or nginx too. 1 - Flash the Arduino\u2122 Sketch using the Arduino IDE 2 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttyMCC \/dev\/ttyS0 3 - Navigate in this folder: cd serial_libraries_examples\/php\/ 4 - Start the embedded web server: php -S 0.0.0.0:8080 5 - Open a browser (on your UDOO or on your computer) and run the examples writing in the address bar: For the basic serial example: http:\/\/127.0.0.1:8080\/index.php For the bidirectional serial example: http:\/\/127.0.0.1:8080\/index_bidirectional.php Please note, use 127.0.0.1 if you open the browser directly on the UDOO; otherwise use 192.168.7.2 if you are using the USB Direct connection on UDOO NEO. If you want to connect from external WiFi\/Ethernet IP address are supported too.","tags":"","url":"Serial_Libraries\/PHP_Serial_Libraries.html"},{"title":"Python Serial Libraries","text":"Python serial libraries for UDOO NEO This file describes how to run the python examples contained in this folder. 1 - Starting from UDOObuntu 2 all the libraries and link should be preinstalled. Otherwise install the Python serial library: sudo apt-get install python-serial 2 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttyMCC \/dev\/ttyS0 3 - Open a terminal and navigate to this folder: cd serial_libraries_examples\/python\/ 4 - Run the python program: for the base python_serial_example.py: python python_serial_example.py for the bidirectional python_serial_example_bidirectional.py: python python_serial_example_bidirectional.py","tags":"","url":"Serial_Libraries\/Python_Serial_Libraries.html"},{"title":"UDOO Android Boot Walkthrough","text":"Overview In the Download page you can find an image of Android 6.0.1 Marshmallow that is still in Beta but almost fully functionally. Android 6 Marshmallow is based on: Android 6.0.1 (tag AOSP android-6.0.1_r50) Kernel 3.14.52 U-Boot v2015.04 Image and Source already provide some useful features and Apps pre-installed like custom settings, rooted image with SuperSU, ADBWireless App, CyanogenMod Terminal, CyanogenMod CMFileManger , TWRP Recovery, NTFS support. Visiting the pages in this section you can find useful guide about how to use the Android Distro of UDOO and How to install GApps. Heads up! We are working to solve the current issues to deliver a complete support: -bug fix to the Bluetooth stack (audio streaming); -Arduino support to Android. At the moment it's not possible to use together Android and Arduino. Sorry for the inconvenient, we are all after this.","tags":"","url":"Cookbook_Android\/UDOO_Android_Boot_Walkthrough.html"},{"title":"UDOO Android Settings","text":"Overview Since the 6.0 Marshmallow version, the UDOO Android distro comes with a custom UDOO section in Setting App to configure custom options for UDOO boards. In General you can find misc custom options to set video output, processor's governor and reboot Android in recovery. Select Video Output In UDOO NEO you have three options as video output. LVDS 7&quot; HDMI The default one at boot is HDMI. Select the Processor's Governor You can select a CPU governor among one of: conservative: Dynamically switch between CPU(s) available if at 75% load. ondemand: Dynamically switch between CPU(s) available if at 95% cpu load. userspace: Run the cpu at user specified frequencies. powersave: Run the cpu at the minimum frequency. interactive: dynamically scales CPU clockspeed in response to the workload placed on the CPU by the user. Significantly more responsive than ondemand. performance: Run the cpu at max frequency. Reboot in TWRP recovery Since Android 6.0 Marshmallow version the UDOO Android distro provides TWRP recovery. Booting Android in Recovery mode allow you to install zip update packages. For example you can install the Open GApps packages to Google Play Services, Play Store and Google Apps. You can find an exhaustive guide of how to install Gapps here. Another way to boot the Android Distro in Recovery Mode is run the following command in the U-Boot console through the Serial Connection: run recovery cmd Alternatively you can use adb tools from you external PC using the command: adb reboot recovery","tags":"","url":"Cookbook_Android\/UDOO_Android_Settings.html"},{"title":"How To Install Gapps On UDOO Running Android","text":"Overview UDOO NEO board ships with a custom build of vanilla Android operating system, the original Android Open Source Project (AOSP). Like you may have noticed when you run Android for the first time, there is no trace of any Google Mobile Services or applications such as Google Play Store, Gmail or others, usually known as Google Apps. You can easily install Google Apps in the newest Android 6.0.1 Marshmallow for UDOO NEO using the Install from zip function of the TWRP recovery we provide with the image. First of all you need to download the OpenGApps package. You can download the package directly on the UDOO Android image running the Browser App. Navigate to OpenGApps and download the right package version choosing: Platform: ARM Android: 6.0 Variant: You can choose different variants depending on the apps you want to install. We usually use and test the nano variants that contains only Play Services, Play Store and few Apps to not overburdening the system. Alternatively you can download GApps package on your external PC and copy it in Android using an USB Drive. When you connect an USB Drive you'll find the partition mounted in a folder like: \/mnt\/media_rw\/&lt;Partition_Name&gt;\/. Navigate in this folders with the App CMFileManager (the Root Access option is needed) and copy the package in the Android SD partition, for example in the path: \/storage\/emulated\/0\/Download\/. Once you have the .zip file in the Android SD card partition you can reboot the board in Recovery Mode to run the TWRP recovery. You can find info about how to reboot the board in Recovery Mode reading the Reboot in TWRP recovery section of the UDOO Android Settings page. Once the TWRP recovery is loaded, enter in the Install menu. Navigate the folder list on the left to find the open_gapps zip package downloaded and click on it. You need to Swipe to confirm Flash. The procedure that install the GApps will start and will take few minutes. Once the procedure end successful you can press the Reboot System. Heads up! The first time you reboot the system after GApps installation a Setup Wizard will start. The wizard will fail but this is an expected behavior(this Google wizard is through to be executed after a fresh Android installation). Just ignore the message by clicking ok. At this point the Google Apps are installed in you system. You can check it navigate the App Menu. Enjoy. Heads up! The first time you reboot the system after GApps installation, and after you set a Google Account, the system could appear slowed because the Google Services and Apps are updating itselfs.","tags":"","url":"Cookbook_Android\/How_To_Install_Gapps_On_UDOO_Running_Android.html"},{"title":"Arduino programming from internal IDE","text":"Please do not download the Arduino IDE from the Arduino website. Follow this guide instead. flash: uploading input firmware failed If you get this error while the IDE is uploading the sketch from internal IDE: \/usr\/bin\/udooneo-m4uploader: line 86: 11091 Bus error $up &quot;$INPUT&quot; 2&gt;&amp;1 flash: uploading input firmware failed Type this command in a terminal and reboot the board. rm \/var\/opt\/m4\/m4last.fw sudo reboot If you get this error while the IDE is uploading the sketch: processing.app.debug.RunnerException at cc.arduino.packages.uploaders.SerialUploader.uploadUsingPreferences(SerialUploader.java:131) at processing.app.debug.Compiler.upload(Compiler.java:165) at processing.app.Sketch.upload(Sketch.java:1167) at processing.app.Sketch.exportApplet(Sketch.java:1141) at processing.app.Sketch.exportApplet(Sketch.java:1113) at processing.app.Editor$DefaultExportHandler.run(Editor.java:2377) at java.lang.Thread.run(Thread.java:745) Caused by: processing.app.SerialException: Error touching serial port '\/dev\/ttyMCC'. at processing.app.Serial.touchForCDCReset(Serial.java:92) at cc.arduino.packages.uploaders.SerialUploader.uploadUsingPreferences(SerialUploader.java:120) ... 6 more Caused by: jssc.SerialPortException: Port name - \/dev\/ttyMCC; Method name - openPort(); Exception type - Port busy. at jssc.SerialPort.openPort(SerialPort.java:162) at processing.app.Serial.touchForCDCReset(Serial.java:86) ... 7 more or ... Bus Error. For the moment it's necessary to reboot the board.","tags":"","url":"Debugging_Troubleshooting\/Arduino_programming_from_internal_IDE.html"},{"title":"Arduino String issue","text":"There are rules to obey due to the different implementation from Arduino. Fixed size allocation Strings that are declared inside a function are allocated automatically at a fixed size. This size is managed through the STRING_STACK_SIZE define in the Wstring.cpp file, that is by default settings equal to 255. Newline While if (inChar == '\\n') is a non-working syntax, if (inChar == '0x0D') works fine. This is found in several examples that retrieve a String from a serial.","tags":"","url":"Debugging_Troubleshooting\/Arduino_String_issue.html"},{"title":"USB stops working after programming M4","text":"When it happens At date we have some problems on managing the serial between the two processors. A too intensive* use may cause malfunctioning. Case 1 It happens each time the Serial.print method is called. When a Serial.print method is called a new buffer is used each time, up to a maximum of 10 buffers. If there is no consumer process that empties each buffer A9-side, when 10 buffers get used, it hangs with various consequences. Be sure that the Arduino sketch will only send data when the A9 consumer process (Python, PHP, C++ program) is ready to consume. Normally after a reboot the Arduino sketch is already running while the A9 side is still starting up. Please make sure your Arduino sketch waits with sending data until the A9 side consuming process confirms to the arduino sketch that it is ready to receive data. Else the 10 buffers will be filled and the Neo will hang. See for an example Arduino code with this feature: https:\/\/github.com\/UDOOboard\/serial_libraries_examples\/tree\/master\/Arduino\/arduino_serial_example_bidirectional The example in Case 2 will not prevent this issue after a reboot. Please use your example arduino_serial_example_bidirectional.ino Case 2 If you instead got this problem void setup(){ Serial.begin(115200); pinMode(13, OUTPUT); } void loop(){ while(Serial.available() &gt; 0){ [ ... ] } } then try if it's possible to add little delays after a Serial call. E.g. void setup(){ Serial.begin(115200); pinMode(13, OUTPUT); delay(100); } void loop(){ while(Serial.available() &gt; 0){ [ ... ] } delay(100); } Solution To solve this problem, [connect via Mini USB](!Basic_Setup\/Remote_Desktop_(VNC)). Once connected open the terminal and remove this file: rm \/var\/opt\/m4\/m4last.fw sudo reboot Then reboot.","tags":"","url":"Debugging_Troubleshooting\/USB_stops_working_after_programming_M4.html"},{"title":"Setup development environment","text":"The recommended OS for developing UDOO Neo is Ubuntu. If you do not use Ubuntu, you will need to install a virtual machine, as indicated in this section. If you are already running Ubuntu on your development computer, you can safely skip this section. Overview In this section we provide a guide to setup a clean and dedicated environment for UDOO Development as: compile kernel compile MQX libraries Download resources Virtual Machine Player VMWare Download Section VMware Workstation Player Operating System Ubuntu Desktop Download Page Installation VMware Ubuntu 14.04 32 bit Open VMware Player and choose &quot;Create a New Virtual Machine&quot; Select &quot;installer disc image (iso)&quot; option and Browse the Ubuntu 14.04 32 image. Click Next. Choose the user full name, username and password. Choose the Virtual machine name and its location. It's recommended to put it into a drive with 30GB free at least. Choose the maximum virtual hard disk size (20 GB is ok) but 30 is recommended. Space is allocated when is needed. Customize hardware. Depending on your host computer choose the amount of ram memory. 1GB should be ok, but 2 is better :) You can also choose the number of dedicated cores. Don't use all the cores for the virtual machine or you host will become unstable. Select OK and then Next. Installation process will start. Insert your password. Now you should access to a Ubuntu 14.04 desktop. Launch the Virtual Machine Install VMware tools If the system ask for install VMware tools we suggest to accept. It provides useful tools like, window resize and direct copy feature. Update the system Open a terminal. sudo apt-get update","tags":"","url":"Advanced_Topics\/Setup_development_environment.html"},{"title":"Compile UDOObuntu (complete bootable image)","text":"Overview Note: The following instructions are referred to a Linux system. A bootable SD card has 3 different elements: U-Boot (Universal Bootloader) Linux Kernel File System (e.g: UDOObuntu) To create a complete UDOObuntu OS image with these three elements compiled from source you can use the mkudoobuntu script. This could be a useful starter point to create also other distros. mkudoobuntu mkudoobuntu creates SD-card images for UDOO QUAD-DUAL. It supports both desktop and headless images. The created images are as small as possible and expanded to the whole card size during the first boot. This script use Debootstrap to compile Ubuntu 14.04 LTS file system and the others UDOO github repos to compile the UDOO's Linux Kernel and U-Boot. This script has been tested on Ubuntu 15.10, 15.04 and 14.04. It may work on other Debian-like system. Download the latest mkudoobuntu revision from GitHub: git clone https:\/\/github.com\/UDOOboard\/mkudoobuntu.git cd mkudoobuntu To debootstrap a new image with a desktop environment(LXDE) use: sudo .\/mkudoobuntu.sh udoo-neo desktop To have a new image minimal without any GUI use: sudo .\/mkudoobuntu.sh udoo-neo minimal You can find more info and commands about this script directly on the Github repo. Once the script finished you can find the .img file in the main mkudoobuntu folder. You can create a bootable microSD from the .img file following this guide: creating a bootable Micro SD card from precompiled image.","tags":"","url":"Advanced_Topics\/Compile_UDOObuntu_(complete_bootable_image).html"},{"title":"Compile U-Boot Bootloader","text":"From the Wikipedia page, the free encyclopedia Das U-Boot (Universal Bootloader) is an open source, primary boot loader used in embedded devices to package the instructions to boot the device's operating system kernel. It is available for a number of computer architectures, including 68k, ARM, AVR32, Blackfin, MicroBlaze, MIPS, Nios, SuperH, PPC and x86. UDOO QUAD-DUAL ARM boards use Das U-Boot. This bootloader initializes the system, and loads kernel and file system to boot the OS. Install the required packages Some packages are needed to compile the U-Boot for UDOO boards. E.g. in Ubuntu 14.04 it is necessary to install the following packages: sudo apt-get update sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib \\ build-essential chrpath socat libsdl1.2-dev xterm picocom ncurses-dev lzop \\ gcc-arm-linux-gnueabihf Get the kernel sources from GitHub Download the latest U-Boot revision from GitHub: git clone https:\/\/github.com\/UDOOboard\/uboot-imx cd uboot-imx To build the U-Boot for UDOO NEO, you can use the master 2015.04-imx branch. This branch is based on NXP\u2122\/Freescale U-Boot fork project. Compile sources The build can be started with: ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make udoo_neo_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make The produced files, SPL and u-boot.img, can be used to boot both Quad and Dual boards. Flash\/Install the U-Boot on a microSD Unmount all the Micro SD partitions: sudo umount \/dev\/&lt;user_name&gt;\/boot sudo umount \/dev\/&lt;user_name&gt;\/rootfs NOTE: Be sure you\u2019 re using the correct device filename (\/dev\/sdX or \/dev\/mmcblkX); use of the wrong device identifier could result in the loss of all data on the Hard Drive of the host PC used. Double check the filename of your device with command: lsblk Flash the files in the SD (e.g. \/dev\/mmcblk0) card with: sudo dd if=SPL of=\/dev\/mmcblk0 bs=1K seek=1 sudo dd if=u-boot.img of=\/dev\/mmcblk0 bs=1K seek=69","tags":"","url":"Advanced_Topics\/Compile_U_Boot_Bootloader.html"},{"title":"Compile Linux Kernel","text":"Install the required packages Some packages are needed to compile the Linux Kernel for UDOO boards. E.g. in Ubuntu 14.04 it is necessary to install the following packages: sudo apt-get update sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib \\ build-essential chrpath socat libsdl1.2-dev xterm picocom ncurses-dev lzop \\ gcc-arm-linux-gnueabihf Get the kernel sources from GitHub Create a develop folder mkdir udoo-dev cd udoo-dev then download the sources: git clone https:\/\/github.com\/UDOOboard\/linux_kernel cd linux_kernel The default branch 3.14-1.0.x-udoo is the one where we are working on for the UDOO QUAD\/DUAL. It is based on 3.14.56 Freescale community kernel. Load the default kernel configuration UDOO Neo has a dedicated default kernel configuration that you can import with: ARCH=arm make udoo_neo_defconfig (optional) Personalize the kernel configuration Add or remove kernel modules to fit your project: ARCH=arm make menuconfig Compile sources To build the kernel image, type: ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make zImage -j5 You can safely tweak the -jX parameter. For instance, on quad core CPUs with two threads per core, you can use -j8. The build can take several minutes, approximately from 2 to 15, depending on your PC host or VM configuration. [...] Kernel: arch\/arm\/boot\/Image is ready LZO arch\/arm\/boot\/compressed\/piggy.lzo CC arch\/arm\/boot\/compressed\/decompress.o CC arch\/arm\/boot\/compressed\/string.o SHIPPED arch\/arm\/boot\/compressed\/hyp-stub.S SHIPPED arch\/arm\/boot\/compressed\/lib1funcs.S SHIPPED arch\/arm\/boot\/compressed\/ashldi3.S SHIPPED arch\/arm\/boot\/compressed\/bswapsdi2.S AS arch\/arm\/boot\/compressed\/hyp-stub.o AS arch\/arm\/boot\/compressed\/lib1funcs.o AS arch\/arm\/boot\/compressed\/ashldi3.o AS arch\/arm\/boot\/compressed\/bswapsdi2.o AS arch\/arm\/boot\/compressed\/piggy.lzo.o LD arch\/arm\/boot\/compressed\/vmlinux OBJCOPY arch\/arm\/boot\/zImage Kernel: arch\/arm\/boot\/zImage is ready Compile Device Trees ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs -j5 Compile the modules ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make modules -j5 Copy the kernel to the SD card You can overwrite the kernel on a UDOObuntu SD card with the following commands: BOOT_PARTITION=\/path\/to\/boot-partition ROOT_PARTITION=\/path\/to\/root-partition cp arch\/arm\/boot\/zImage $BOOT_PARTITION cp arch\/arm\/boot\/dts\/*.dtb $BOOT_PARTITION\/dts ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make firmware_install modules_install INSTALL_MOD_PATH=$ROOT_PARTITION Heads up! Be aware that if you have used the DTEditor previously, u-boot will load DTBs from \/boot\/dts-overlay. Disable this via \/boot\/uEnv.txt or copy your modified DTBs to that directory.","tags":"","url":"Advanced_Topics\/Compile_Linux_Kernel.html"},{"title":"Compile Android From Source","text":"This describes the necessary steps to start and use the pre-compiled Android software support package for UDOO NEO Board. Moreover, a description of how to rebuild the bootloader, kernel and Android file system is provided. The procedure described in this wiki refers to UDOO NEO. System Requirements Android system for UDOO NEO board is provided as precompiled images or as source code to be customized and rebuilt. Running the full procedure described in this wiki, rebuilding the Android system from source files, it is necessary to have an host PC (or Virtual Machine) running Ubuntu Linux 14.04 64bit with at least 40 GB of free disk space, configured in the set up the work environment section below. The host PC should also include: an SD\/\u00b5SD card reader; an host pc with internet connection; a microUSB cable to connect UDOO NEO to host and access debug serial (optional); Terminology The set of scripts and images necessary to run Android on a board is generically called a Distro. Setting up a Linux build environment Regarding the development environment, you need to first make sure to comply with the AOSP (Android Open Source Project) requirements. Note that it requires a 64-bit version of Linux. Follow this official link for Establishing a Build Environment. We suggest to use a Virtual Machine environment to create a close and dedicated workspace. It reduce risks of procedure and libraries mismatching or to corrupt other working enviroments present on the host machine. Building 5.x Lollipop and 6.0.x Marshmallow versions for UDOO NEO only requires to have OpenJDK v7 (the v8 as specified in the official Android docs is required only to compile the next Android N). ~$ sudo apt-get install openjdk-7-jdk The packages needed to build the AOSP In addition to the AOSP requirements, the following packages are needed to build NXP\/Freescale components: ~$ sudo apt-get install uuid uuid-dev zip lzop gperf zlib1g-dev \\ liblz-dev liblzo2-2 liblzo2-dev u-boot-tools lib32z1 flex git-core \\ curl mtd-utils android-tools-fsutils At this page you can find how to create a Virtual Machine for Development. Remember you need a 64 bit Linux Distro to compile Android. Serial communication While not exactly necessary, serial communication with UDOO NEO is strongly recommended as the first debug method. In order to use the serial debug port on UDOO NEO, after connecting the board and host PC ports, it is necessary to install and setup an application for serial communication, such as minicom. At this page you can find how to Conecting via Serial Cable. The serial debug port is used for two different reasons: The bootloader and kernel send debug messages via serial port, so that the user can monitor the low level system state; a root console is opened on the serial port, allowing bootloader configuration and system control. The number of messages sent via serial port can be very high. For this reason, it is quite useful to increase scrolling capabilities of the terminal, possibly setting them to a very high or even unlimited. Download the source code Next step is downloading the source code. To do so you need the repo tool which has been developed especially for Android in order to manage the hundreds of Git repositories this project contains: ~$ cd ~ ~$ mkdir myandroid bin ~$ curl http:\/\/commondatastorage.googleapis.com\/git-repo-downloads\/repo &gt; ~\/bin\/repo ~$ chmod a+x ~\/bin\/repo ~$ cd myandroid ~$ ~\/bin\/repo init -u https:\/\/github.com\/UDOOboard\/android_udoo_platform_manifest -b android-6.0.1 ~$ ~\/bin\/repo sync -j5 N.B. the repo sync loads the repos needed. Therefore, it can take several hours to load. The -jN command run N tasks at the same time to speed up this process. Configure the environment Prior to build the system, it is necessary to configure the Android environment for the specific build. In particular, the following commands have to be launched: ~$ export ARCH=arm ~$ source build\/envsetup.sh Finally, it is necessary to choose which target to build. The command below shows a list of possible targets ~$ lunch For each possible target, the first part of the name indicates the board you are building for, while the second part selects the build type, as described here. In particular, valid options to build for UDOO NEO board are: udooneo_6sx-user: build for production, with limited access udooneo_6sx-eng: build for development, with root access and additional debugging tools The target selection can alternatively be done directly at command line, calling for example ~$ lunch udooneo_6sx-eng Once all these steps are done, several environment variables are set. Among the rest, it is worth noting the environment variable OUT, automatically set to udoo-android-dev]\/out\/target\/product\/udooneo_6sx, that is the folder where Android system is actually built, and where object files, folders and system images are created. From now on, this folder is called [OUT]. Build Android system image The easiest but most time-consuming step in building Android is to build the Android system image. In general, after configuring the environment as in configuration section, it is sufficient to launch the following command (from the main folder [udoo-android-dev]) to build the whole system image, including the kernel: The code: ~$ make The duration of the whole system build is strongly dependent on the host PC you are working on, but this can take up to several hours, and builds more than 20GB of compiled code (this is the size of the [udoo-android-dev]\/out\/ folder when the operation is completed). Enabling parallel compilation can speed up the process. In general, the idea is to let the compiler to launch several compiling jobs in parallel, where the number of jobs depends on the specific PC you are working on. ~$ make -jN where N is the maximum number of parallel jobs allowed. For a better explanation of this point (included the value to assign to N), please consult http:\/\/source.android.com\/source\/building.html, in Build the Code section above. Several files and folders are created in [OUT]. Among the rest we underline: root\/ and ramdisk.img: root file system and generated image recovery\/ and ramdisk-recovery.img: root file system used in recovery mode, and generated image system\/ and system.img: Android system including binaries and libraries, and generated image data\/ and userdata.img: Android data area and generated image kernel and uImage: kernel images boot.img: kernel and initial root ramdisk, generated from kernel and ramdisk.img recovery.img: kernel and initial root ramdisk used in recovery mode, generated from kernel and ramdisk-recovery.img u-boot.imx: the U-Boot bootloader. This is the first executed binary that loads the kernel and all the system. The images are sufficient to boot UDOO NEO board with the default kernel configuration. Create a microSD from the Android built files Once the new Android system images are created, it is necessary to prepare a \u00b5SD card with the images and boot UDOO NEO board. A script is provided to help with this step. In a way similar to what is described in the Run Android section, the script will partition and format the SD card and then copies the new Android images into the correct partitions, reading them directly from [$OUT]. It is sufficient to follow the next steps. Connect the SD card to your host PC, and use the dmesg or fdisk -l commands to find the device name; we suppose it is \/dev\/sdc. Launch the script to prepare the SD ~$ cp make_sd.sh $OUT ~$ cd $OUT ~$ sudo -E .\/make_sd.sh \/dev\/sdc When this is done, the SD card containing the images is ready to boot UDOO NEO as described in the Boot Android from SD section. Prepare a Distro It is sometimes useful to prepare a new Distro to be stored. To do this, once the new images are built following the procedures described in the previous Sections, it is sufficient to call the command ~$ .\/prepare_distro.sh [distro_name] The script creates a new folder [distro_name], containing the freshly built Android system images, and the scripts to use them. An archive [distro_name].tar.gz is also prepared for distribution. Once the archive is ready, you can follow the above section to create a microSD from the Android built files. Boot Android from microSD When the make_sd script ends, insert the SD into the SD card slot and power up the device. The Android system boots. You can see the Android bootscreen on a connected HDMI monitor within 20 seconds, while messages on the serial debug port start to be sent almost immediately. First of all, messages from the bootloader can be seen. Among the rest, characteristics of the board are shown: CPU type, boot device and memory size. Please check the correctness of this information. The kernel is automatically launched after a 3 second countdown. The first time Android System boots, it must configure the storage amd prepare folders for data and applications. As a consequence, every time the SD is prepared with the procedure described in this section, the first boot takes around 1 minute, while subsequent boots are much faster. At the end of the boot procedure, you can interact with the system either with mouse and keyboard and the HDMI display, or with a root console automatically opened in serial. Build Kernel The kernel is built together with the rest of the Android system. However, it is also possible to modify the configuration and rebuild it separately. As for the bootloader, the kernel can be configured and customized for a very wide range of boards and peripherals. Linux kernel customization is a very complex task, an in-depth description is out of the scope of this document. Here we consider only the default configuration to run linux kernel on UDOO NEO board. It is possible to configure (or restore) the kernel to the default configuration for the Module calling the command below: The command: ~$ make -C kernel_imx udoo_neo_android_defconfig If you wish to check the configuration or customize it, use ~$ make -C kernel_imx menuconfig The command opens a graphical configuration tool. Any saved change is stored in the same folder as an hidden file called .config, which then is the actual configuration file used to compile the kernel. Once the configuration is ready, the kernel is compiled with command ~$ make bootimage This operation can take up to 30 minutes to complete, and performs several actions: builds the kernel, creating the images uImage and zImage in [udoo-android-dev]\/kernel_imx\/arch\/arm\/boot copies the kernel images in [OUT] (zImage is renamed to kernel) updates root\/ and ramdisk.img updates boot.img from ramdisk.img and kernel When it is done, the new boot.img is present in [OUT], ready to be used to boot the Module. Android Build system caches most of the file compiled, sometimes it may happen that some changes aren't reported in the final compiled boot.img. If this happens we suggest to delete from the $OUT folder these file: boot.img, kernel, obj\/KERNEL_OBJ\/* in order to recompile all the Kernel.","tags":"","url":"Advanced_Topics\/Compile_Android_From_Source.html"},{"title":"Recompile MQX Libraries","text":"The Arduino software stack runs on a base real-time operating system (RTOS) installed on the Cortex-M4 of i.MX 6SoloX. The RTOS is MQX\u2122 from NXP. This section help you to compile the MQX\u2122 software stacks. First of all you need to download and uncompress the MQX 4.1 for i.MX6SX (Linux hosted). You need to have an NXP account to accept the license and download the source package. Heads up! Be sure to download this version MQX RTOS for i.MX 6SoloX v4.1.0 releases and patches specific for i.MX 6SoloX processor. You can download from the Previous section. Apply the UDOO patches In this repo udooneo_mqx41_patch you can find the changes made on the MQX stack to make the UDOO NEO's M4 core behave like an Arduino. Enter in the MQX source directory and clone the udoo patch. git clone https:\/\/github.com\/UDOOboard\/udooneo_mqx41_patch Then apply patches to the sources. patch -p1 &lt; .\/udooneo_mqx41_patch\/mqx4.1_udooneo.patch Compile MQX\u2122 Compilation Makefile are here: to Compile: Freescale_MQX_4_1_IMX6SX\/build\/imx6sx_sdb_m4\/make\/build_gcc_arm.sh, to Clean: Freescale_MQX_4_1_IMX6SX\/build\/imx6sx_sdb_m4\/make\/clean_gcc_arm.sh Compiler version Version 4.8 doesn't let PWM works. Should be used version 4.9. Should be edited Freescale_MQX_4_1_IMX6SX\/build\/common\/make\/global.mak setting the toolchain path depending of your configuration: TOOLCHAIN_ROOTDIR = \/usr\/local\/gcc-arm-none-eabi-4_9-2014q4","tags":"","url":"Advanced_Topics\/Recompile_MQX_Libraries.html"},{"title":"Boot process","text":"When the board is powered on, the CPU executes code in its internal ROM, loading the first sectors of the SD card. In this way the U-Boot boot-loader is loaded and executed. The boot-loader This thin layer of software takes care of initialize some registers, devices (like the PMIC) and RAM time settings. It is composed of two stages, the first is called SPL (secondary program loader) which initializes several things: arch_cpu_init() initializes some registers, the watchdog, the DMA, etc; ccgr_init initializes CCGR registers in the CCM (Clock Controller Module); board_early_init_f initializes the M4 core and the pads of the UART1; timer_init initializes CPU timers and clock sources; preloader_console_init initializes serial port communications and prints the message &quot;U-Boot SPL 2015.04-00267-gd781468 (Dec 16 2015 - 14:44:56)&quot;; spl_dram_init sets board-specific DRAM configuration (UDOO Neo Basic has 512MB of RAM and different timings); memset zeros BSS memory; board_init_r continues the boot, loading the second stage of the boot-loader. In the second stage, more devices and registers are initialized. I2C buses, LVDS, Ethernet, Wireless and motions sensors pads are initialized. The PFUZE3000 power regulator is setup and MMC is initialized so files can be read from it. The uEnv.txt file Once the hardware is correctly initialized, the uEnv.txt file is read from the FAT \/boot partition. This file contains a few options to override some default settings, like the main video output (which defaults to HDMI). Variable name Default value Possible values video_output hdmi hdmi, lvds7, disabled m4_enabled true true, false use_custom_dtb false true, false Those variables (screen type, M4 core status and the use of custom device tree) are used to select the correct device tree file to load. Linux kernel boot The last step is to load the Linux kernel zImage and the device tree file, both from the \/boot partition: reading \/zImage 4376112 bytes read in 232 ms (18 MiB\/s) Booting from mmc ... reading dts-overlay\/imx6sx-udoo-neo-full-hdmi-m4.dtb 45210 bytes read in 35 ms (1.2 MiB\/s) Kernel image @ 0x80800000 [ 0x000000 - 0x42c630 ] ## Flattened Device Tree blob at 83000000 Booting using the fdt blob at 0x83000000 Using Device Tree in place at 83000000, end 8300e099 Switched to ldo_bypass mode! Starting kernel ... [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 3.14.56-udooneo-01989-.....","tags":"","url":"Advanced_Topics\/Boot_process.html"},{"title":"Overview","text":"i.MX 6SoloX embeds on a single chip a single core ARM Cortex A9 and a ARM cortex M4 microcontroller. For any deep inquiry regarding i.MX 6SoloX, please have a look at the dedicated reference manual made by Freescale. They can use and share lot of hardware implemented features provided by the architecture as: GPIOs UARTs I2Cs SPIi analogs ADCs These two processors are connected to all interfaces and peripherals through an high speed AXI bus. It\u2019s up to the programmer or the &quot;system&quot; admin to define witch features are assigned to each processors. All the hardware features block can be accessed and connected via processors pad with a editable muxing. So the functions are not fixed but can accessed on different pads. Some of these pads are connected to external pins to allow the users to connect their stuff. External pins (orange) are by default assigned to A9 in GPIO mode. So these pins can be controlled directly from the file system (Linux, Android). Internal pins (blue) are assigned and controlled by Cortex M4 with the same dimensions of Arduino UNO pinout. All the Arduino shields compatible can be plugged directly on UDOO Neo board. Pinout Available features I.MX 6SoloX provides the following functions, part of them are fully available on the pinout. Hardware features In the following tables are listed all the functional block with relative signals and pin numbers. In some cases the same signal are available in more then one pin. UART serial ports PORT Signal Name Internal Pin External Pin UART1 UART1_TX_DATA 47 UART1_RX_DATA 46 UART2 UART2_TX_DATA 45 UART2_RX_DATA 44 UART3 UART3_TX_DATA RESERVED FOR BLUETOOTH CHIP UART3_RX_DATA RESERVED FOR BLUETOOTH CHIP UART5 UART5_TX_DATA 0 UART5_RX_DATA 1 UART6 UART6_RI_B 40 UART6_DSR_B 39 UART6_DTR_B 38 UART6_DCD_B 37 UART6_RX_DATA 36 UART6_TX_DATA 35 UART6_RTS_B 34 UART6_CTS_B 33 I2C PORT Signal Name Internal Pin External Pin I2C1 I2C1_SCL 26 I2C1_SDA 27 I2C2 I2C2_SCL 36 14 - SCL I2C2_SDA 37 15 - SDA I2C3 I2C3_SCL RESERVED FOR LCD \/ HDMI I2C3_SDA RESERVED FOR LCD \/ HDMI I2C4 I2C4_SCL 32 34 I2C4_SDA 33 35 CAN PORT Signal Name Internal Pin External Pin CAN1 CAN1_RX 40 CAN1_TX 41 CAN2 CAN2_RX 42 CAN2_TX 43 PWM - Pulse Width Modulation PORT Signal Name Internal Pin External Pin PWM1 PWM1_OUT 3 PWM2 PWM2_OUT 4 PWM3 PWM3_OUT 16 5 PWM4 PWM4_OUT 17 6 PWM5 PWM5_OUT 30 7 PWM6 PWM6_OUT 31 9 PWM7 PWM7_OUT 11 PWM8 PWM8_OUT 10 CSI - Camera PORT Signal Name Internal Pin External Pin CSI1 CSI1_VSYNC 24 CSI1_HSYNC 25 CSI1_DATA02 26 CSI1_DATA03 27 CSI1_DATA04 28 CSI1_DATA05 29 CSI1_DATA06 30 CSI1_DATA07 31 CSI1_DATA08 32 CSI1_DATA09 33 SPI PORT Signal Name Internal Pin External Pin ECSPI2 MISO 20 MOSI 21 SCLK 38 SS0 39 ECSPI3 MISO 18 A1 MOSI A0 READY SCLK A4 SS0 A5 19 SS1 21 SS2 22 ECSPI5 MISO 40 MOSI 43 SCLK 42 SS0 41","tags":"","url":"Hardware_Reference\/Overview.html"},{"title":"Resources","text":"Schematics Here you can find the schematics files of the UDOO X86: Schematics Top Bottom Bill of Material (BOM) Here you can find the Bill of Materials(BOM) file of the UDOO X86: Bill of Material (BOM) Mechanical Specs - 3D Design Files Here you can find the mechanical specs files of the UDOO X86: UDOO NEO 3D-2D Design File","tags":"","url":"Hardware_Reference\/Resources.html"},{"title":"Board versions","text":"Basic 512 MB DDR3 RAM Wi-Fi\/Bluetooth module is not mounted. Network connection is provided by the 10\/100 Mbps fast Ethernet RJ45 port. 9-axis motion sensors (accelerometer, magnetometer and gyroscope) are not mounted. Extended 1 GB DDR3 RAM. Wi-Fi\/Bluetooth module is mounted No 10\/100 Mbps fast Ethernet RJ45 port. 9-axis motion sensors are embedded on board. Full 1 GB DDR3 RAM. Wi-Fi\/Bluetooth module is mounted 10\/100 Mbps fast Ethernet RJ45 port. 9-axis motion sensors are embedded on board. Basic Extended Full RAM 512 MB DDR3 1 GB DDR3 1 GB DDR3 Wifi \/ Bluetooth NO YES YES Ethernet 10\/100 YES NO YES 9-axis Motion Sensor No YES YES","tags":"","url":"Hardware_Reference\/Board_versions.html"},{"title":"Processor","text":"The board is equipped with Freescale i.MX 6SoloX. It is the first SoC exploiting both the ARM Cortex-A9 and ARM Cortex-M4 cores. The i.MX 6SoloX applications processor offers a highly integrated multi-market solution. Enables secure, connected homes and vehicles within the Internet of Things (IoT) Delivers secure and robust implementation to enable concurrent execution of multiple software environments Provides for an application-rich system with real-time responsiveness Maintains maximum effectiveness and security when portioning system resources such as memory and peripherals Backed by a strong enablement ecosystem for better customer solutions and faster time-to-market Main Features 1x ARM\u00ae Cortex\u2122-A9 up to 1 GHz 512 KB L2 cache 32 KB instruction and data caches NEON SIMD media accelerator 1x ARM\u00ae Cortex\u2122-M4 up to 200 MHz 16 KB instruction and data caches 64 KB TCM MPU and FPU GPU 2D\/3D Vivante GC400T 17Mtri\/s 133Mpxl\/s Open GL ES 2.0 Camera Interface 20-bit parallel CMOS sensor interface NTSC\/PAL analog video input interface","tags":"","url":"Hardware_Reference\/Processor.html"},{"title":"RAM","text":"UDOO Neo is equipped with two different chips depending on the model. UDOO Neo Basic: 2x MT41K128M16 UDOO Neo Extended and UDOO Neo Full: 2x MT41K256M16 Both memory modules are provided by Micron with a 400 MHz RAM clock. DDR3L SDRAM (1.35V) is a low-voltage version of the DDR3 (1.5V) SDRAM.","tags":"","url":"Hardware_Reference\/RAM.html"},{"title":"Power Management","text":"The board is equipped with the Freescale MMPF3000. The PF3000 is a Power Management Integrated Circuit (PMIC) designed specifically for use with the Freescale i.MX 7 and i.MX 6SL\/SX\/UL application processors. With up to four buck converters, six linear regulators, RTC supply, and coin-cell charger, the PF3000 can provide power for a complete system, including applications processors, memory, and system peripherals. This device is powered by SMARTMOS technology. To be fully functional, the board needs a 5V clean power (VCC_SW). If an LVDS panel is connected, the board must be powered at 12V. We can power the board with an external power supply or with a microUSB cable connected to a 5V source. Power supply stages The (E) block allows to only one wire to arrive at VCC_SW node. this block is controlled by to signals: 5V_PWRG and the output of (D) block. 5V_PWRG is a signal that notify the voltage coming from the (A) block has the right value and eventually the VCC_SW_IN can be used to power the board. The (A) block is a DC\/DC converter to a 5V voltage. The (B) block is the uUSB port. The (D) block detect witch power supply is connected and eventually send signals to switch the source for VCC_SW The (F) block is another DC\/DC converter from 5V to 3.3V. Power sources You can power up the board in 3 ways DC-jack with a standard 5.5mm\/2.1mm barrel jack: internal positive, Voltage 6 to 15. microUsb: 5 Volts up to 2 Ampere Vin \/ GND pin on internal pinout: from 5V to 12V, min 2A. (If you are having problems powering the board with 5V, there may be a problem of leakage from the power supply. Try with a higher voltage e.g. 6V). Providing higher voltages could damage the board!","tags":"","url":"Hardware_Reference\/Power_Management.html"},{"title":"PC USB interface","text":"USB The board can be connected to a PC with a MicroUSB port. It can be used in OTG mode and in HOST mode. PC Connection Interface If you connect UDOO Neo to your PC, you can: access to a mass storage create a network interface between PC and UDOO Neo create a serial connection g_multi (Multifunction Composite Gadget) To implements these features we use a kernel module called g_multi. This module include other usefull sub-modules: usb_f_rndis usb_f_acm usb_f_mass_storage Network interface UDOO Neo inetwork interface name: usb0 UDOO Neo IPv4 address: 192.168.7.2 Serial port From UDOO Neo you can see your PC as: \/dev\/ttyGS0 From your Linux PC you can see UDDO Neo serial connection as: \/dev\/ttyACM0 If you are using Windows the OS assign a COMxx name Mass storage The accessible mass storage is a FAT partition called &quot;boot&quot; where is possible to find: documentation sources uEnv file kernel binary","tags":"","url":"Hardware_Reference\/PC_USB_interface.html"},{"title":"Indicator LED","text":"Three LEDs are placed on the board, close to the RTC clock battery plug and to the Ethernet connector. They have three different colors: Orange, connected to Arduino pin 13. By default it is available from M4 core; Red, by default it is connected to A9 and shows SD card input\/output activity; Green, connected to PMIC. It turns on when the chip is powered.","tags":"","url":"Hardware_Reference\/Indicator_LED.html"},{"title":"JTAG header","text":"The pads to connect a JTAG debugger are embedded on board, placed on the bottom of the board. The connector is not present to reduce the used space and the costs. On these pads the I2C1 is also available.","tags":"","url":"Hardware_Reference\/JTAG_header.html"},{"title":"VADC Analog Camera","text":"The iMX 6soloX processor implements a 4 channel Video ADC block. Two of these channels are exported on the external pinout in the J12 JST connector. Exported channels are: VADC_IN0 VADC_IN1 Schematics J12 Connector The two video signals are available on the J12 connector, including a ground reference: Connector signals The signals related to the image below are: RED: analog Video Input channel 0 GRAY: ground signals GREEN: analog Video Input channel 1 How to create your connector As soon as possible you'll be able to buy a specific cable on the shop. For the moment it is possible to create an RCA cable as in the following picture. External: ground Internal: signal","tags":"","url":"Hardware_Reference\/VADC_Analog_Camera.html"},{"title":"Ethernet","text":"The MAC-NET core of i.MX 6SoloX, in conjunction with a 10\/100 MAC, implements layer 3 network acceleration functions. These functions are designed to accelerate the processing of various common networking protocols, such as IP, TCP, UDP, and ICMP, providing wire speed services to client applications. A physical layer is implemented by KSZ8091RNA chip. The KSZ8091RNA is a single-supply 10Base-T\/100Base-TX Ethernet physical-layer transceiver for transmission and reception of data over standard CAT-5 unshielded twisted pair (UTP) cable. Reference Datasheet","tags":"","url":"Hardware_Reference\/Ethernet.html"},{"title":"Python","text":"UDOO Library 2.0, by David Smerkous A library that makes the Linux side act like a shield to the Arduino side (TCP, UDP Server\/Client and Storage, Usb and soon to come audio). Hackster link (including a Tutorial): https:\/\/www.hackster.io\/smerkousdavid\/udoo-library-2-0-9ca0d5?ref=platform&ref_id=497_recent___&offset=2 GitHub link: https:\/\/github.com\/smerkousdavid\/Udoo-Library Python Library, by David Smerkous A Python library to control the Gpios, Accel, Gyro, Temp, Baro, Magno sensors\/pins easily. Github link: https:\/\/github.com\/smerkousdavid\/Neo.GPIO MAGUM, by Francesco Guerri, Orla3 and Umberto Cucini Magum, that stands for Magnetometer, Accelerometer and Gyroscope UDOO Management, is a Python library that allows you to completely manage all three senors built in UDOO Neo. MAGUM has been tested on UDOO Neo rev. D, with UDOObuntu RC1 version. With MAGUM you can: get data from all registers and write on them too monitor in real time the values obtained by the sensors using algorithms that use both accelerometer and gyroscope to detect orientation, and magnetometer to measure magnetic fields Hackster link:https:\/\/www.hackster.io\/ubalance-team\/magum-sensors-library-222d96?ref=user&ref_id=58345&offset=0 Download it on GitHub:https:\/\/github.com\/ubalance-team\/magum\/archive\/master.zip","tags":"","url":"UDOO_NEO_made_by_the_Community\/Python.html"},{"title":"Java","text":"Java Tools for UDOO NEO, by Cyril BOSSELUT Java tools for UDOO Neo board are a set of java class allowing access to GPIOs, sensors, serial port, a complete REST service and to an 16\u00d72 LCD wired using GPIOs. Those tools are published under GPL V2 and source are available for download on Github https:\/\/github.com\/BOSSoNe0013\/NeoJava Forum link: https:\/\/www.udoo.org\/forum\/threads\/java-tools-for-udoo-neo-board.3159\/ Push request are also welcome. Latest release added accelerometer, magnetometer and gyroscope sensors support. It also includes Java\u202c client for the \u202a#\u200eREST\u202c service, \u202a#\u200eUDOONEO\u202c Controller, allowing you to easily managed GPIOs through a network connection GitHub link: https:\/\/github.com\/BOSSoNe0013\/UDOONeoController Forum link: https:\/\/www.udoo.org\/forum\/threads\/java-tools-for-udoo-neo-board.3159\/","tags":"","url":"UDOO_NEO_made_by_the_Community\/Java.html"},{"title":"Builds based on other kernels","text":"Debian Jessie, by Igor Pe\u010dovnik Legacy CLI Debian jessie Board: Kernel 3.14.55 (development version) with some hardware support, headers and some firmware included. Link: http:\/\/www.armbian.com\/udoo-neo\/","tags":"","url":"UDOO_NEO_made_by_the_Community\/Builds_based_on_other_kernels.html"},{"title":"Drivers Modules And Tools","text":"ServoCardboard UDOO, by harlem88_gis aka Antonio Gisondi Move servo cam on UDOO with Google Cardboard. YouTube video: https:\/\/www.youtube.com\/watch?v=BDFrv2x50Lw Github link: https:\/\/github.com\/harlem88\/ServoCardboardUdoo Linux Driver 3 Interfaces, by tcmichals aka Tim Michals Linux\u202c driver that exposes 3 interfaces to user space. Allows user space apps to use epoll for async type of applications. All Things Embedded link: http:\/\/allthingsembedded.blogspot.it\/2015\/12\/udoo.html Drive link: https:\/\/drive.google.com\/folderview?id=0B0wXCQunUlRjTW1VT2FBb3BQY3M&usp=sharing Wifi STA mode, by tcmichals aka Tim Michals All Things Embedded link: http:\/\/allthingsembedded.blogspot.it\/2015\/11\/wifi-sta-mode-working-with-neo-udoo.html UDOONEOREST, by marksull aka Mark Sullivan Rest API for interacting with UDOO Neo GPIOs, motion sensors and brick sensors. Link: https:\/\/rubygems.org\/gems\/udooneorest Node JS module for Barometric Sensor by fabdrol aka Fabian Tollenaar Node.js module for retrieving data from the barometer brick for the UDOO Neo. Gets atmospheric pressure in pascals, temperature in kelvin and altitude in meters. Github link: https:\/\/github.com\/fabdrol A program to upload Arduino sketches via UDOOFOTA by klakier2121 Github link: https:\/\/github.com\/klakier2121\/udooneo_wifi UDOO NEO and openocd working, by Tim Michals Link: http:\/\/allthingsembedded.blogspot.it\/search?updated-min=2016-01-01T00:00:00-08:00&updated-max=2017-01-01T00:00:00-08:00&max-results=1","tags":"","url":"UDOO_NEO_made_by_the_Community\/Drivers_Modules_And_Tools.html"}]}